[{"title":"如何理解递归和迭代","url":"http://gruad.github.io/2017/08/11/如何理解递归和迭代/","content":"<p>递归递归，要理解递归，首先要理解递归。醉了啊。很早之前学习第一门语言C的时候，那个时候刷题，图的广度、深度遍历、动态规划等等<br>对这些应用递归思想的还是蛮熟的，现在回头发现自己应该都没以前熟了，什么回溯了，什么动态规划了，什么迭代了，递归等等，都特么忘差不多啦。<br>本文是简单记录一下，以便以后遇到问题，好查阅。关于引用的，已注明参考文章出处，不做任何商业用途，只是便于自己查阅，如有侵权还望联系本人删除即可。</p>\n<h3 id=\"递归（recursion）-rɪˈkɜ-rʃn\"><a href=\"#递归（recursion）-rɪˈkɜ-rʃn\" class=\"headerlink\" title=\"递归（recursion） [rɪˈkɜ:rʃn]\"></a>递归（recursion） [rɪˈkɜ:rʃn]</h3><p><strong>JavaScript运行的内核引擎都有很严格的堆栈大小限制</strong><br>递归是自己调用自己，不断的缩小问题的规模（将问题不断的缩小更小的规模），遇到递归出口再<strong>原路</strong>返回。因此必须保存这些计算过程中的中间值，<br>这些中间值压如入栈中，因此当问题规模很大时，会占用大量内存。</p>\n<h3 id=\"迭代（iteration）-ˌɪtəˈreʃən\"><a href=\"#迭代（iteration）-ˌɪtəˈreʃən\" class=\"headerlink\" title=\"迭代（iteration） [ˌɪtəˈreʃən]\"></a>迭代（iteration） [ˌɪtəˈreʃən]</h3><p>迭代是不断的调用，目的是无限的接近目标（逐渐逼近），用新值覆盖旧值。不保存中间量，内存利用率高。</p>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//迭代n!</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">iteration</span>(<span class=\"params\">n</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> s=<span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\ts*=i;</div><div class=\"line\">\t&#125;</div><div class=\"line\"><span class=\"keyword\">return</span> s;</div><div class=\"line\">&#125;</div><div class=\"line\">iteration(<span class=\"number\">4</span>);</div><div class=\"line\"><span class=\"comment\">// 递归n!</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recursion</span>(<span class=\"params\">n</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</div><div class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> recursion(n)*recursion(n<span class=\"number\">-1</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">recursion(<span class=\"number\">4</span>);</div></pre></td></tr></table></figure>\n<h3 id=\"使用递归和迭代注意事项\"><a href=\"#使用递归和迭代注意事项\" class=\"headerlink\" title=\"使用递归和迭代注意事项\"></a>使用递归和迭代注意事项</h3><ol>\n<li>递归算法与迭代算法的设计思路区别在于：函数或算法是否具备收敛性，当且仅当一个算法存在预期的收敛效果时，<br>采用递归算法才是可行的，否则，就不能使用递归算法。</li>\n<li>当然，从理论上说，所有的递归函数都可以转换为迭代函数，反之亦然，然而代价通常都是比较高的。但从算法结构来说，递归声明的结构并不总能够转换为迭代结构，<br>原因在于结构的引申本身属于递归的概念，用迭代的方法在设计初期根本无法实现，这就像动多态的东西并不总是可以用静多态的方法实现一样。<br>这也是为什么在结构设计时，通常采用递归的方式而不是采用迭代的方式的原因，一个极典型的例子类似于链表，使用递归定义及其简单<br>，但对于内存定义(数组方式)其定义及调用处理说明就变得很晦涩，尤其是在遇到环链、图、网格等问题时，使用迭代方式从描述到实现上都变得很不现实。</li>\n<li>递归其实是方便了程序员难为了机器。它只要得到数学公式就能很方便的写出程序。优点就是易理解，容易编程。但递归是用栈机制实现的，<br>每深入一层，都要占去一块栈数据区域，对嵌套层数深的一些算法，<br>递归会力不从心，空间上会以内存崩溃而告终，而且递归也带来了大量的函数调用，这也有许多额外的时间开销。所以在深度大时，它的时空性就不好了。<br>循环其缺点就是不容易理解，编写复杂问题时困难。优点是效率高。运行时间只因循环次数增加而增加，没什么额外开销。空间上没有什么增加。</li>\n<li>局部变量占用的内存是一次性的，也就是O(1)的空间复杂度，而对于递归（不考虑尾递归优化的情况），每次函数调用都要压栈，那么空间复杂度是O(n)，和递归次数呈线性关系。</li>\n<li>递归程序改用循环实现的话，一般都是要自己维护一个栈的，以便状态的回溯。如果某个递归程序改用循环的时候根本就不需要维护栈，那其实这个递归程序这样写只是意义明显一些，<br>不一定要写成递归形式。但很多递归程序就是为了利用函数自身在系统栈上的auto变量记录状态，以便回溯。</li>\n<li>原理上讲，所有递归都是可以消除的，代价就是可能自己要维护一个栈。而且我个人认为，很多情况下用递归还是必要的，它往往能把复杂问题分解成更为简单的步骤，<br>而且很能反映问题的本质。</li>\n</ol>\n<p>递归其实就是利用系统堆栈，实现函数自身调用，或者是相互调用的过程。在通往边界的过程中，都会把单步地址保存下来，知道等出边界，再按照先进后出的进行运算，<br>这正如我们装木桶一样，每一次都只能把东西方在最上面，而取得时候，先放进取的反而最后取出。递归的数据传送也类似。但是递归不能无限的进行下去，<br>必须在一定条件下停止自身调用，因此它的边界值应是明确的。就向我们装木桶一样，我们不能总是无限制的往里装，必须在一定的时候把东西取出来。<br>比较简单的递归过程是阶乘函数，你可以去看一下。但是递归的运算方法，往往决定了它的效率很低，因为数据要不断的进栈出栈。</p>\n<p>但是递归作为比较基础的算法，它的作用不能忽视。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://zhuanlan.zhihu.com/p/24085518\" target=\"_blank\" rel=\"external\">知乎</a></p>\n<p><a href=\"http://nxlhero.blog.51cto.com/962631/1231228\" target=\"_blank\" rel=\"external\">漫谈递归和迭代</a></p>\n","categories":["算法"],"tags":["递归和迭代"]},{"title":"DNS解析过程详解","url":"http://gruad.github.io/2017/08/11/DNS解析过程详解/","content":"<h3 id=\"什么是DNS\"><a href=\"#什么是DNS\" class=\"headerlink\" title=\"什么是DNS?\"></a>什么是DNS?</h3><p>NDS(domain name system)域名系统。互联网上计算机通信靠唯一的IP.而计算机是无法识别域名的，或者或人去计IP也不太现实。<br>NDS是应用层的协议，在UDP协议之上。使用端口号53。是Internet网上作为域名和IP地址相互映射的一个分布式数据库。</p>\n<h3 id=\"DNS功能\"><a href=\"#DNS功能\" class=\"headerlink\" title=\"DNS功能\"></a>DNS功能</h3><p>每个IP地址都可以有一个主机名，主机名由一个或多个字符串组成，字符串之间用小数点隔开。有了主机名，就不要死记硬背每台IP设备的IP地址，<br>只要记住相对直观有意义的主机名就行了。这就是DNS协议所要完成的功能。</p>\n<h3 id=\"DNS解析过程\"><a href=\"#DNS解析过程\" class=\"headerlink\" title=\"DNS解析过程\"></a>DNS解析过程</h3><p>比如在浏览器中输入www.qq.com 域名：<br><img src=\"/img/domain.png\" alt=\"\"></p>\n<ol>\n<li>首先浏览器会调用本机的DNS客户端，发送请求，UDP协议。操作系统会首先检查本地的hosts文件是否有这个网络网址映射，如果有就调用这个IP映射，完成域名解析。</li>\n<li>如果hosts文件没有这个地址映射，这开始查找<strong>本地DNS解析器缓存</strong> 是否有这个网址映射关系，如果有则直接返回，完成解析。</li>\n<li>如果本地hosts文件和本地DNS解析器缓存都没有相应的网址映射关系，则首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它<strong>本地DNS服务器</strong>，<br>此服务器接收到到请求，如果要查询的域名，包含在<strong>本地配置区域资源</strong>，则返回解析结果给客户机（端），完成域名解析，此解析具有权威性。 </li>\n<li>如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</li>\n<li>如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，<br>根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，<br>将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)<br>给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找就会找ee.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。 </li>\n<li>如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，<br>以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</li>\n</ol>\n<p><strong>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</strong></p>\n<p><strong>递归：自己调用自己，目的在于缩小问题的规模。</strong></p>\n<p><strong>迭代：不自己执行很多次，目的是不断的接近目标。</strong></p>\n<h3 id=\"简单抽象\"><a href=\"#简单抽象\" class=\"headerlink\" title=\"简单抽象\"></a>简单抽象</h3><p>假设运行在用户主机上的某些应用程序（如Webl浏览器或者邮件阅读器）需要将主机名转换为IP地址。这些应用程序将调用DNS的客户机端，并指明需要被转换的主机名。<br>（在很多基于UNIX的机器上，应用程序为了执行这种转换需要调用函数gethostbyname（））。用户主机的DNS客户端接收到后，向网络中发送一个DNS查询报文。<br>所有DNS请求和回答报文使用的UDP数据报经过端口53发送（至于为什么使用UDP，请参看为什么域名根服务器只能有13台呢？ - 郭无心的回答）<br>经过若干ms到若干s的延时后，用户主机上的DNS客户端接收到一个提供所希望映射的DNS回答报文。这个查询结果则被传递到调用DNS的应用程序。因此，<br>从用户主机上调用应用程序的角度看，<strong>DNS是一个提供简单、直接的转换服务的黑盒子</strong>但事实上，实现这个服务的黑盒子非常复杂，<br>它由分布于全球的大量DNS服务器以及定义了DNS服务器与查询主机通信方式的应用层协议组成。</p>\n","categories":["DNS"],"tags":["DNS解析"]},{"title":"我心中未来的共享单车应该有的人工智能","url":"http://gruad.github.io/2017/08/09/我心中未来的共享单车应该有的人工智能/","content":"<p><strong> 以下文章全是自己的胡思乱想，大胆想象以下未来的人工智能单车。 </strong></p>\n<h3 id=\"自己的体验\"><a href=\"#自己的体验\" class=\"headerlink\" title=\"自己的体验\"></a>自己的体验</h3><p>今天在寻找摩拜共享单车的时候，突然想到的一个问题，记录一下。摩拜单车的定位还是比较准确的，据说里面嵌入了定位芯片。而不是像ofo单车的使用手机定位，导致出现很多僵尸车，在使用寻找的过程中出现很大的困难，用户体验极差（当然确实好骑，轻便。但现在的摩拜第二代也开始改进，轻便了不少）。在运营、单车回收投放方面也出现困难。（当然可能ofo它压根没有想过回收，哈哈哈哈，毕竟回收的人工成本大于回收的收益）。虽然摩拜的定位已经很准确了，但在我使用体验过程中，突然想到的，还是有可以改进或未来在人工智能方面可以应用的功能。</p>\n<h3 id=\"预约功能的胡思乱想\"><a href=\"#预约功能的胡思乱想\" class=\"headerlink\" title=\"预约功能的胡思乱想\"></a>预约功能的胡思乱想</h3><p>比如，今天使用了一下摩拜的预约功能，在这里解释一下预约功能。在摩拜共享单车的app上，选择距离你比较近的单车，点击选中，即可预约。一但你预约成功，这辆单车在15分钟内，你找到解锁即可使用，在这15分钟内，这辆单车其他用户是无法使用的。而且单车上有预约灯会在夜晚闪烁，便于用户找到。（突然想到，白天呢，是不是加个响铃，在距离接近100米或其他距离的时候，可以用手机控制与单车的互联功能，选择是否开启响铃，以便用户自己找到单车。哈哈哈，不知道容不容易实现哈）</p>\n<h3 id=\"为何是一定是人去寻找车，而不是车来寻找人呢？\"><a href=\"#为何是一定是人去寻找车，而不是车来寻找人呢？\" class=\"headerlink\" title=\"为何是一定是人去寻找车，而不是车来寻找人呢？\"></a>为何是一定是人去寻找车，而不是车来寻找人呢？</h3><p>另外的一个大胆想法就是：为何一定是人去寻找车，而不是车来寻找人呢？这是不是一个产品在用户使用过程中的痛处？多多少少用户会有点不太舒服。用户在寻找车的过程中，或者说人与车的距离较短时，还好。但当距离相对于用户要使用单车去的距离来说相近时，这岂不是就是一个很大的痛苦了呢？如何来解决这个问题，我的想法就是：让车变得智能起来，让车来寻找用户。比如，当用户想使用单车的时候，在地图上寻找定位距离自己比较近的单车（就像预约功能一样选中），让单车开启无人驾驶模式，来主动行到用户身边。（哈哈哈，脑洞有点大，不过据说荷兰已经研究出了一款智能婴儿车，可以自动刹车啦，躲避障碍物啦，无人驾驶等等，好像现在据说快递也有人发明了，无人的送快递智能车）。</p>\n<h3 id=\"如何解决自行车平衡性\"><a href=\"#如何解决自行车平衡性\" class=\"headerlink\" title=\"如何解决自行车平衡性\"></a>如何解决自行车平衡性</h3><p>这个时候有人就会想了，它只是一个自行车啊，你这搞的也太复杂了。（其实之前看过谷歌无人驾驶自行车，感觉好牛逼，不过后来被证实是假的，概念车，有骗到你吗？哈哈哈。貌似百度一下，看百度也在做，我去，厉害了，我的度<a href=\"https://baike.baidu.com/item/无人驾驶自行车/14890713?fr=aladdin\" target=\"_blank\" rel=\"external\">百度的无人驾驶自行车</a>我是写完这篇文章，才看到的。我去。。。反正我相信未来技术人工智能可以实现的）其实可以不用搞这么复杂的，你完全可以不用像我上面说的做成4个轮子的类似机器人一样的庞然大物。你只需要解决自行车的平衡问题就可以，其实我觉得因为我的知识有限，应该存在有很好的解决方案，可以做到自行车的无人行驶（解决平衡性问题）。我的低沉本解决方案就是，就像小时候的儿童自行车那样，只需要给自行车的后轮加两个小型辅助轮（可以收缩）即可。而自行车可以有两种状态，一个是无人行驶状态（辅助轮出现），一种是人使用状态（辅助轮收起即可。哈哈哈，有点像变形金刚了啊，可以叫它变形自行车）。这个时候有出现问题了，如何给无人行驶的自行车提供动力呢，或者说它行驶的动力来源是什么？按个电池？那不就是电动车了嘛。当然也出现过共享电动车，而且成本也很高。能不能降低成本？我认为是有更好的解决方案的。比如以下：</p>\n<h3 id=\"太阳能充电或用户机械能存储\"><a href=\"#太阳能充电或用户机械能存储\" class=\"headerlink\" title=\"太阳能充电或用户机械能存储\"></a>太阳能充电或用户机械能存储</h3><p>比如可以让自行车白天在太阳底下自己充电（太阳能自行车，哈哈哈）存储电能。这样可以解决动力来源问题。也可以在用户使用过程中，把用户的机械能转化成动能（脚踩发电存储起来，哈哈哈），这样是不是就解决了动力来源问题呢，当然有很多细节问题哈，我是胡思乱想的就没考虑。比如如果自行车没电了这个问题，（这应该是产品运营过程中的问题）当然可以采取预警低电量的自行车，然后地图上打上标记，然后采取激励机制，用户使用的这些低电量预警自行车就会有奖励啦（比如现金，贡献值，反正如果做产品的话，可以激发用户的使用热情就好，应该有很多方案。我就不多说了哈，想到好的激励方案，我再写），这就可以激发用户去使用这些低电量的单车，这样这些单车就可以在用户使用过程中，存储电能。哈哈哈，这机制也是醉了。巴拉巴拉了这么多，我自己想的越来越多了。不扯了，有时间再胡思乱想吧。</p>\n<h3 id=\"让自行车变成真正的“自行”\"><a href=\"#让自行车变成真正的“自行”\" class=\"headerlink\" title=\"让自行车变成真正的“自行”\"></a>让自行车变成真正的“自行”</h3><p>如果真的在未来实现的话，会不会出现这种情况，路上行驶的有很多无人的自行车，哈哈哈，这景象现在想起来还是怪吓人的。不过我想随着科技的发展，世界上只会有你想不到的，没有实现不了的。不如在古代谁能想到可以做飞机在天上飞来飞去呢？</p>\n","categories":["胡思乱想"],"tags":["共享单车,人工智能"]},{"title":"互联网协议入门学习笔记","url":"http://gruad.github.io/2017/08/09/互联网协议入门学习笔记/","content":"<h2 id=\"Internet-Protocol-Suite-互联网协议组）\"><a href=\"#Internet-Protocol-Suite-互联网协议组）\" class=\"headerlink\" title=\"Internet Protocol Suite(互联网协议组）\"></a>Internet Protocol Suite(互联网协议组）</h2><ul>\n<li>1.物理层</li>\n<li>2.链接层</li>\n<li>3.网络层</li>\n<li>4.传输层（UDP和TCP)</li>\n<li>5.应用层</li>\n</ul>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"external\">维基百科互联网协议</a></p>\n<h2 id=\"互联网协议分层模型\"><a href=\"#互联网协议分层模型\" class=\"headerlink\" title=\"互联网协议分层模型\"></a>互联网协议分层模型</h2><p>网上有七层模型和四层模型，按照自己理解分五层模型，从下到上：1.物理层、2.链接层、3.网络层、4.传输层、5.应用层。越下面越靠近硬件，越上面越靠近用户。</p>\n<h2 id=\"1-物理层—传输0和1。\"><a href=\"#1-物理层—传输0和1。\" class=\"headerlink\" title=\"1.物理层—传输0和1。\"></a>1.物理层—传输0和1。</h2><h2 id=\"2-链接层—单纯的0和1没有意义，必须规定解读方式，多少人电信号算一组，每个信号位有何意义？这就是链路层的意义，规定0和1分组方式。\"><a href=\"#2-链接层—单纯的0和1没有意义，必须规定解读方式，多少人电信号算一组，每个信号位有何意义？这就是链路层的意义，规定0和1分组方式。\" class=\"headerlink\" title=\"2.链接层—单纯的0和1没有意义，必须规定解读方式，多少人电信号算一组，每个信号位有何意义？这就是链路层的意义，规定0和1分组方式。\"></a>2.链接层—单纯的0和1没有意义，必须规定解读方式，多少人电信号算一组，每个信号位有何意义？这就是链路层的意义，规定0和1分组方式。</h2><p><strong>链接层不能解决不同子网络之间的通信（MAC地址依广播方式传送）,所以网络层的出现解决不同子网之间的通信和传输</strong><br>2.1 以太网协议<br>   以太网规定一组信号组成一个帧（frame）,一个帧包含标头head和数据data。<br>   网卡（MAC地址）为48为二进制，12为十六进制表示。<br>   传播方式为广播。</p>\n<h2 id=\"3-网络层—网络层的诞生，它引入一套新的地址，使我们能够区分不同计算机是否属于同一个子网络。这套地址就叫做网络地址：网址。网络地址是管理员随机分配的，和MAC地址随机组合。\"><a href=\"#3-网络层—网络层的诞生，它引入一套新的地址，使我们能够区分不同计算机是否属于同一个子网络。这套地址就叫做网络地址：网址。网络地址是管理员随机分配的，和MAC地址随机组合。\" class=\"headerlink\" title=\"3.网络层—网络层的诞生，它引入一套新的地址，使我们能够区分不同计算机是否属于同一个子网络。这套地址就叫做网络地址：网址。网络地址是管理员随机分配的，和MAC地址随机组合。\"></a>3.网络层—网络层的诞生，它引入一套新的地址，使我们能够区分不同计算机是否属于同一个子网络。这套地址就叫做网络地址：网址。网络地址是管理员随机分配的，和MAC地址随机组合。</h2><p><strong>网络地址确定计算机所在的子网络，MAC地址将数据包送到该子网络的目标网卡，</strong>因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p>\n<p>3.1 IP地址</p>\n<p>规定网络地址的协议，叫做IP协议。—IP协议现在用的是IPv4 是32位二进制组成：172.0.0.1（10101100 00000000 00000000 00000001）0.0.0.0~255.255.255.255</p>\n<p>比如前24位表示网络号，后8位表示主机号，可是我们怎么知道前多少位代表网络号呢，所以就出现了<strong>子网掩码</strong>，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0</p>\n<p>3.1.1. 判断是否在一个子网络方法：</p>\n<p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>\n<h2 id=\"4-传输层（UDP和TCP）\"><a href=\"#4-传输层（UDP和TCP）\" class=\"headerlink\" title=\"4.传输层（UDP和TCP）\"></a>4.传输层（UDP和TCP）</h2><p>有了MAC地址和IP地址就可以实现网络中两个主机之间的通信了，但是存在一个问题，现在计算机都是多线程，不同应用都需要用到网络，比如你一边浏览网页，一边和朋友聊天，那么计算机改如何确定发来的信息属于哪个呢？<br><strong>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port）</strong><br>它其实是每个使用网卡的程序的编号，每个数据包就发送到特定的端口，所以不同的程序就能取到自己所需要的数据。”端口”是0到65535之间的一个整数，正好<strong>16个二进制位</strong>。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>\n<p><strong>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</strong></p>\n<h2 id=\"5-应用层—“应用层”的作用，就是规定应用程序的数据格式。（不太理解）\"><a href=\"#5-应用层—“应用层”的作用，就是规定应用程序的数据格式。（不太理解）\" class=\"headerlink\" title=\"5.应用层—“应用层”的作用，就是规定应用程序的数据格式。（不太理解）\"></a>5.应用层—“应用层”的作用，就是规定应用程序的数据格式。（不太理解）</h2><p>应用层接收到“传输层”传来的数据，接下来要开始解读。由于互联网是开放的，数据五花八门，必须先规定好格式，否则根本无法解读。</p>\n<p><img src=\"/img/protocol.png\" alt=\"\"></p>\n","categories":["网络基础"],"tags":["互联网协议"]},{"title":"JavaScript中正则表达式学习笔记","url":"http://gruad.github.io/2017/08/09/JavaScript中正则表达式学习笔记/","content":"<p><a href=\"http://refiddle.com/\" target=\"_blank\" rel=\"external\">正则在线测试地址</a><br><a href=\"https://deerchao.net/tutorials/regex/regex.htm\" target=\"_blank\" rel=\"external\">号称30分钟学习地址</a></p>\n<h3 id=\"1-元字符（metacharacter）\"><a href=\"#1-元字符（metacharacter）\" class=\"headerlink\" title=\"1 元字符（metacharacter）\"></a>1 元字符（metacharacter）</h3><ul>\n<li>\\b :代表着单词的开头或结尾，也就是单词的分界处。<br>虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。</li>\n<li>‘.’ :是另一个元字符，匹配除了换行符以外的任意字符。</li>\n<li>‘’星号’<em>‘ :同样是元字符，不过它代表的不是字符，也不是位置，而是数量——它指定</em>前边的内容可以连续重复使用任意次以使整个表达式得到匹配。</li>\n<li>\\d :是个新的元字符，匹配一位数字(0，或1，或2，或……)。</li>\n<li>\\s :匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等。</li>\n<li>\\w :匹配字母或数字或下划线或汉字等。</li>\n<li>‘+’ :这里的+是和’<em>‘类似的元字符，不同的是’</em>‘匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。</li>\n<li>^    :匹配字符串的开始</li>\n<li>$ :匹配字符串的结尾</li>\n</ul>\n<h3 id=\"2-常用限定符\"><a href=\"#2-常用限定符\" class=\"headerlink\" title=\"2 常用限定符\"></a>2 常用限定符</h3><ul>\n<li>‘*’    重复零次或更多次</li>\n<li>‘+’    重复一次或更多次</li>\n<li>?    重复零次或一次</li>\n<li>{n}    重复n次</li>\n<li>{n,}    重复n次或更多次</li>\n<li>{n,m}    重复n到m次</li>\n</ul>\n<h3 id=\"3-反义\"><a href=\"#3-反义\" class=\"headerlink\" title=\"3 反义\"></a>3 反义</h3><ul>\n<li>\\W    匹配任意不是字母，数字，下划线，汉字的字符</li>\n<li>\\S    匹配任意不是空白符的字符</li>\n<li>\\D    匹配任意非数字的字符</li>\n<li>\\B    匹配不是单词开头或结束的位置</li>\n<li>[^x]    匹配除了x以外的任意字符</li>\n<li>[^aeiou]    匹配除了aeiou这几个字母以外的任意字符</li>\n</ul>\n","categories":["JavaScript"],"tags":["正则表达式"]},{"title":"JavaScript中回调函数的理解","url":"http://gruad.github.io/2017/08/09/JavaScript中回调函数的理解/","content":"<h3 id=\"回调函数定义\"><a href=\"#回调函数定义\" class=\"headerlink\" title=\"回调函数定义\"></a>回调函数定义</h3><p>A callback is a function that is passed as a argument to anther function and is executed after its parent function has cpmpleted.<br>英文中的定义好理解多了，特别是nodejs学习过程中，大量的回调函数，高并发，单线程概念等等。</p>\n","categories":["JavaScript"],"tags":["回调函数"]},{"title":"前端MVC和前段生态的理解","url":"http://gruad.github.io/2017/08/09/前端MVC和前段生态的理解/","content":"<p> MVC概念理解：</p>\n<pre><code>Model:提供/保存数据（管理数据）\nController:数据处理，实现业务逻辑\nView：展示数据，提供用户界面\n</code></pre><p>前端发展历程：</p>\n<pre><code>以前的前端工程师相当于模板工程师，负责编写前端页面模板\nAjax技术诞生，改变了一切\nWeb2.0时代到来\nWeb2.0:动态页面，富交互，前端数据处理\n</code></pre><p>前端 MVC 框架：</p>\n<pre><code>前端通过Ajax得到数据，因此也有了处理数据的需求\n前端代码变的也需要保存数据、处理数据、生成视图，这导致了前端MVC框架的诞生。\n</code></pre><p>MVVM模式：</p>\n<pre><code>View-Model:简化的Controller，唯一作用就是为View提供处理好的数据，不含其它逻辑。\n</code></pre><p>REST接口：</p>\n<pre><code>前后端分离以后，它们之间通过接口通信。\n后端暴露出接口，前端消费后端提供的数据。\n后端接口一般是REST形式，前后端的通信协议一般是HTTP。\n</code></pre><p>Node:</p>\n<pre><code>2009年，Node项目诞生，它是服务器上的JavaScript运行环境。\nNode=javascript+操作系统API\n</code></pre><p>Node的意义：</p>\n<pre><code>javascript成为服务器脚本语言，与Python和Ruby一样\njavascript成为唯一的浏览器和服务器都支持的语言\n前端工程师可以编写后端程序了\n</code></pre><p>前端开发模式的根本改变：</p>\n<pre><code>1.Node环境下开发\n2.大量使用服务器端工具\n3.引入持续集成等软件工程的标准流程\n4.开发完成后，编译成浏览器可以运行的脚本，放上CDN\n</code></pre><p>全栈工程师：</p>\n<pre><code>一个人负责开发前端和后端\n从数据库到UI的所有开发\n</code></pre><p>全栈技能：</p>\n<pre><code>需要掌握的技能:\n\n1.传统前端技能：HTML/JavaScript/CSS\n2.一门后端语言\n3.移动端开发：IOS/Android/HTML5\n4.其他技能：数据库、HTTP等等\n</code></pre><p>未来软件的特点：</p>\n<pre><code>1.联网\n2.高并发\n3.分布式\n4.跨终端\n</code></pre><p>h5提供了两种客户端存储数据的新方法：</p>\n<pre><code>1.localStorage-没有时间限制的数据存储\n2.sessionStorage-针对一个session的数据存储\n</code></pre><p>h5中数据不是由每个服务器请求传递的，而是只有在请求时使用数据，它是的不影响网站性能的情况下存储大量数据成为可能。</p>\n<p>对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。</p>\n<p>h5使用JavaScript来存储数据和访问数据。</p>\n","categories":["前端MVC"],"tags":["前端"]},{"title":"前端模块化认识","url":"http://gruad.github.io/2017/08/08/前端模块化认识/","content":"<p><a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\" target=\"_blank\" rel=\"external\">AMD规范</a><br><a href=\"https://github.com/seajs/seajs/issues/242\" target=\"_blank\" rel=\"external\">CMD规范</a></p>\n<h3 id=\"什么事模块化\"><a href=\"#什么事模块化\" class=\"headerlink\" title=\"什么事模块化\"></a>什么事模块化</h3><p>模块化因为nodeJs火了之后，变得特别火，前端模块化开发也变的特别流行，关于模块化，之前在实习的时候也学习过和用过，也总结过，今天就一次梳理一下。</p>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>nodejs中是一个包就是一个模块，可以用require引用别人写好的包的功能和属性，所以可见：模块应该是具有相同属性和行为的事物的集合。在前端中，一般一个js文件就称为一个模块。每个模块只关注与自身的事情，<strong> 同时模块也会引用其他的模块，所以为了解决模块之间的依赖和命名冲突， </strong> 就出现了一些模块化的规范。其中CommonJS，AMD(asyn module define),CMD（common module define）。下面依次介绍它们。</p>\n<h3 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h3><p>CommonJS是服务器端的模块的规范，NodeJS将其发扬光大，标志着JavaScript模块化编程规范的出现。</p>\n<h4 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>CommonJS规范规定一个单独的文件就是一个模块，每一个模块都是一个单独的作用域，在该模块内部的变量无法被其它模块读取，除非定义为global对象的属性。</p>\n<ul>\n<li>require()用来引入外部依赖</li>\n<li>exports<strong>对象</strong>用于导出当前对象的方法或属性，唯一的导出口</li>\n<li>module<strong>对象</strong>就代表模块本身<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// sum 模块的定义</span></div><div class=\"line\">exports.sum=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\"><span class=\"comment\">// 模块的引入</span></div><div class=\"line\"><span class=\"keyword\">var</span> math=<span class=\"built_in\">require</span>(<span class=\"string\">'./sum'</span>)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">n</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> math.sum(val,n)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>AMD允许输出模块规范兼容CommonJs<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require,exports,module</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> reqModule=<span class=\"built_in\">require</span>(<span class=\"string\">'./someModule'</span>)</div><div class=\"line\">  reqModule.test()</div><div class=\"line\">exports.test=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"comment\">// dosomething</span></div><div class=\"line\">&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>然而CommonJS模块加载是同步的，这在服务器端很容易实现，但是在浏览器端实现起来会出现很多问题。</p>\n<h3 id=\"AMD-Asynchronous-Module-Definition\"><a href=\"#AMD-Asynchronous-Module-Definition\" class=\"headerlink\" title=\"AMD(Asynchronous Module Definition)\"></a>AMD(Asynchronous Module Definition)</h3><p>AMD异步模块定义，它是一个在浏览器端模块化开发的规范。由于不是JavaScript原生支持的，使用AMD规范进行页面开发需要用对应的库，RequireJS就是其中最出名的一个，实际上，AMD是RequireJS在推广过程中对模块定义的规范化的产出。<br>RequireJs主要解决两个问题：</p>\n<ol>\n<li>实现js文件的一部加载，避免网页失去响应。</li>\n<li>解决管理模块之间的依赖性，便于代码的编写和维护。<h3 id=\"define函数\"><a href=\"#define函数\" class=\"headerlink\" title=\"define函数\"></a>define函数</h3>RequireJS定义了一个define函数，它是一个全局变量，用来定义模块，描述如下：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(id?,dependencies?,factory)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>id：可选参数，定义中模块的名字，若没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。</li>\n<li>dependencies：一个当前模块依赖的，已被模块定义的模块标识的数组字面量。该参数可选，若忽略该参数，它默认为[“require”, “exports”, “module”]。</li>\n<li>factory：模块初始化要执行的函数或对象。若为函数，它应该只被执行一次。若为对象，该对象应该为模块的输出值。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 依赖已数组形式传递，并以形参传入回调函数中</span></div><div class=\"line\">define([<span class=\"string\">'module1'</span>,<span class=\"string\">'module2'</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module1,module2</span>)</span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// dosomething</span></div><div class=\"line\">      module1.test();</div><div class=\"line\">      module2.test();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">foo</span>:foo&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"require函数\"><a href=\"#require函数\" class=\"headerlink\" title=\"require函数\"></a>require函数</h3><p>RequireJS还定义了一个require函数用来加载模块，描述如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reuqire([dependencies],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;);</div></pre></td></tr></table></figure></p>\n<p>require函数接受两个参数，第一个参数是一个数组，表示所依赖的模块。第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块要以参数形式传入该函数，在回调函数内部才可以使用这些模块。</p>\n<p><strong> require函数在加载依赖模块的时候是异步加载的，这样浏览器就不会失去响应，它指定的回调函数，也只有在前面的模块都加载成功后，才会运行，这样就解决了依赖性的问题。</strong></p>\n<h3 id=\"CMD-common-Module-Definition\"><a href=\"#CMD-common-Module-Definition\" class=\"headerlink\" title=\"CMD(common Module,Definition)\"></a>CMD(common Module,Definition)</h3><p>CMD(Common Module Definition)翻译成中文就是通用模块定义。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。和AMD一样，使用CMD规范也需要相应的库函数，SeaJS就是其中一个。实际上，CMD是SeaJS在推广过程中对模块定义的规范化的产出。SeaJS要解决的问题和RequireJS一样，只不过在模块定义方式和模块加载的时机上有些区别。</p>\n<h3 id=\"define函数-1\"><a href=\"#define函数-1\" class=\"headerlink\" title=\"define函数\"></a>define函数</h3><p>CMD规范的define函数和AMD规范的描述相同。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(id?,dependencies?,factory)</div></pre></td></tr></table></figure></p>\n<p>但是CMD推崇一个文件一个模块，所以经常用文件名作为模块id。同时，CMD推崇就近依赖，所以一般不在define函数的参数中写依赖，而是在factory函数中就近写。</p>\n<h3 id=\"factory函数\"><a href=\"#factory函数\" class=\"headerlink\" title=\"factory函数\"></a>factory函数</h3><p>factory函数有三个参数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">factory(<span class=\"built_in\">require</span>,exports,<span class=\"built_in\">module</span>)</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// CMD写法：</span></div><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require,exports,module</span>)</span></div><div class=\"line\"><span class=\"function\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> a=<span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)</div><div class=\"line\">    a.test()</div><div class=\"line\">    <span class=\"keyword\">if</span>(status)&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> b=<span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>)</div><div class=\"line\">        b.test()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// AMD写法:</div><div class=\"line\">define([&apos;./a&apos;,&apos;./b&apos;],function(a,b) &#123;</div><div class=\"line\">  a.test()</div><div class=\"line\">  b.test()</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>require</p>\n<p>require是一个方法，它接受模块标识作为唯一的参数，用来导入其他的模块，获取其它模块提供的接口。</p>\n<p>export</p>\n<p>exports是一个对象，用来向外部提供接口。</p>\n<p>module</p>\n<p>module是一个对象，存储了去模块相关联的一些属性和方法。</p>\n<h3 id=\"AMD与CMD的区别知乎大神总结\"><a href=\"#AMD与CMD的区别知乎大神总结\" class=\"headerlink\" title=\"AMD与CMD的区别知乎大神总结\"></a>AMD与CMD的区别<a href=\"https://www.zhihu.com/question/20351507\" target=\"_blank\" rel=\"external\">知乎大神总结</a></h3><p>首先我们知道，AMD是RequireJS 在推广过程中对模块定义的规范化产出。CMD是SeaJS在推广过程中对模块定义的规范化产出</p>\n<ol>\n<li>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.</li>\n<li>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。CMD推崇就近依赖，只有在用到某个模块的时候再去require。</li>\n<li>AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。</li>\n</ol>\n<p>作者：玉伯<br>链接：<a href=\"https://www.zhihu.com/question/20351507/answer/14859415\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/20351507/answer/14859415</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。（还不懂，没见过）</p>\n<ol>\n<li>AMD是异步并行加载，在AMD的规范下，同时异步加载是不会产生错误的。而CMD的机制不同，这种加载方式会产生错误，但是如果能规范化模块的内容形式，也可以异步并行加载。<br><a href=\"http://hyuhan.com/2016/09/13/about-module/\" target=\"_blank\" rel=\"external\">这位姐姐的总结</a>，尊重原创。</li>\n</ol>\n","categories":["模块化"],"tags":["前端模块化"]},{"title":"JavaScript中this理解","url":"http://gruad.github.io/2017/08/08/JavaScript中this理解/","content":"<p>本来要总结的，才发现这个博主总结和理解的太好了<a href=\"https://www.ibm.com/developerworks/cn/web/1207_wangqf_jsthis/index.html\" target=\"_blank\" rel=\"external\">深入浅出JavaScript中的this</a>如需理解，还请转入原博主,就像作者说的过段时间又会忘了，所以要深刻理解消化掉。<br>以下我粗略记一下笔记</p>\n<h3 id=\"this出现的背景\"><a href=\"#this出现的背景\" class=\"headerlink\" title=\"this出现的背景\"></a>this出现的背景</h3><p>在Java等面向对象的语言中，this关键字含义明确且具体，即指代当前对象，一般在编译期确定下来，而JavaScript中this是动态的，在运行期才确定下来。<br>在Java中定义类经常用到关键字this，多数情况下是为了避免命名冲突。比如在下面例子的中，定义一个 Point 类，很自然的，大家会使用 x，y 为其属性或成员变量命名，在构造函数中，使用 x，y 为参数命名，相比其他的名字，比如 a，b，也更有意义。这时候就需要使用 this 来避免命名上的冲突。另一种情况是为了方便的调用其他构造函数，比如定义在 x 轴上的点，其 x 值默认为 0，使用时只要提供 y 值就可以了，我们可以为此定义一个只需传入一个参数的构造函数。无论哪种情况，this 的含义是一样的，均指当前对象。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x=<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> y=<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(x,y)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.x=x;<span class=\"comment\">// 在构造函数中，使用 x，y 为参数命名，相比其他的名字，比如 a，b，</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.y=y;<span class=\"comment\">// 也更有意义。这时候就需要使用 this来避免命名上的冲突。</span></div><div class=\"line\">\t</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(y)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>(<span class=\"number\">0</span>,y);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"JavaScript中this\"><a href=\"#JavaScript中this\" class=\"headerlink\" title=\"JavaScript中this\"></a>JavaScript中this</h3><p>由于其运行期绑定的特性，所以JavaScript中this含义丰富的多。它可以是全局对象，当前对象或者任意对象，这完全取决于函数的调用方式。</p>\n<h3 id=\"JavaScript中函数四种调用方式\"><a href=\"#JavaScript中函数四种调用方式\" class=\"headerlink\" title=\"JavaScript中函数四种调用方式\"></a>JavaScript中函数四种调用方式</h3><ol>\n<li>作为对象方法调用。</li>\n<li>作为普通函数调用。</li>\n<li>作为构造函数调用。</li>\n<li>使用apply或call调用。<br>下面我们将按照调用方式的不同，分别讨论 this 的含义。<h3 id=\"作为对象方法调用\"><a href=\"#作为对象方法调用\" class=\"headerlink\" title=\"作为对象方法调用\"></a>作为对象方法调用</h3>在 JavaScript 中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this 被自然绑定到该对象。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> point=&#123;</div><div class=\"line\">\tx:<span class=\"number\">0</span>,</div><div class=\"line\">\ty:<span class=\"number\">0</span>,</div><div class=\"line\">\tmoveTo:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.x=<span class=\"keyword\">this</span>.x+x;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.y=<span class=\"keyword\">this</span>.y+y;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">point.moveTo(<span class=\"number\">1</span>,<span class=\"number\">1</span>)<span class=\"comment\">// //this 绑定到当前对象，即 point 对象</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"作为普通函数调用\"><a href=\"#作为普通函数调用\" class=\"headerlink\" title=\"作为普通函数调用\"></a>作为普通函数调用</h3><p>函数也可以直接被调用，此时 this 绑定到全局对象。在浏览器中，window 就是该全局对象。比如下面的例子：函数被调用时，this 被绑定到全局对象，接下来执行赋值语句，相当于隐式的声明了一个全局变量，这显然不是调用者希望的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeNoSense</span>(<span class=\"params\">x</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.x=x;</div><div class=\"line\">&#125;</div><div class=\"line\">makeNoSense(<span class=\"number\">5</span>);</div><div class=\"line\">x;<span class=\"comment\">// x 已经成为一个值为 5 的全局变量</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"（类闭包）不准确哈\"><a href=\"#（类闭包）不准确哈\" class=\"headerlink\" title=\"（类闭包）不准确哈\"></a>（类闭包）不准确哈</h3><p>对于内部函数，即声明在另外一个函数体内的函数，这种绑定到全局对象的方式会产生另外一个问题。我们仍然以前面提到的 point 对象为例，这次我们希望在 moveTo 方法内定义两个函数，分别将 x，y 坐标进行平移。结果可能出乎大家意料，不仅 point 对象没有移动，反而多出两个全局变量 x，y。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> point = &#123; </div><div class=\"line\">x : <span class=\"number\">0</span>, </div><div class=\"line\">y : <span class=\"number\">0</span>, </div><div class=\"line\">moveTo : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123; </div><div class=\"line\">    <span class=\"comment\">// 内部函数</span></div><div class=\"line\">    <span class=\"keyword\">var</span> moveX = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; </div><div class=\"line\">    <span class=\"keyword\">this</span>.x = x;<span class=\"comment\">//this 绑定到了哪里？</span></div><div class=\"line\">   &#125;; </div><div class=\"line\">   <span class=\"comment\">// 内部函数</span></div><div class=\"line\">   <span class=\"keyword\">var</span> moveY = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123; </div><div class=\"line\">   <span class=\"keyword\">this</span>.y = y;<span class=\"comment\">//this 绑定到了哪里？</span></div><div class=\"line\">   &#125;; </div><div class=\"line\"> </div><div class=\"line\">   moveX(x); </div><div class=\"line\">   moveY(y); </div><div class=\"line\">   &#125; </div><div class=\"line\">&#125;; </div><div class=\"line\">point.moveTo(<span class=\"number\">1</span>, <span class=\"number\">1</span>); </div><div class=\"line\">point.x; <span class=\"comment\">//==&gt;0 </span></div><div class=\"line\">point.y; <span class=\"comment\">//==&gt;0 </span></div><div class=\"line\">x; <span class=\"comment\">//==&gt;1 </span></div><div class=\"line\">y; <span class=\"comment\">//==&gt;1</span></div></pre></td></tr></table></figure></p>\n<p>这属于 JavaScript 的设计缺陷，正确的设计方式是内部函数的 this 应该绑定到其外层函数对应的对象上，为了规避这一设计缺陷，聪明的 JavaScript 程序员想出了变量替代的方法，约定俗成，该变量一般被命名为 that。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> point = &#123; </div><div class=\"line\">x : <span class=\"number\">0</span>, </div><div class=\"line\">y : <span class=\"number\">0</span>, </div><div class=\"line\">moveTo : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123; </div><div class=\"line\">     <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>; </div><div class=\"line\">    <span class=\"comment\">// 内部函数</span></div><div class=\"line\">    <span class=\"keyword\">var</span> moveX = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; </div><div class=\"line\">    that.x = x; </div><div class=\"line\">    &#125;; </div><div class=\"line\">    <span class=\"comment\">// 内部函数</span></div><div class=\"line\">    <span class=\"keyword\">var</span> moveY = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123; </div><div class=\"line\">    that.y = y; </div><div class=\"line\">    &#125; </div><div class=\"line\">    moveX(x); </div><div class=\"line\">    moveY(y); </div><div class=\"line\">    &#125; </div><div class=\"line\">&#125;; </div><div class=\"line\">point.moveTo(<span class=\"number\">1</span>, <span class=\"number\">1</span>); </div><div class=\"line\">point.x; <span class=\"comment\">//==&gt;1 </span></div><div class=\"line\">point.y; <span class=\"comment\">//==&gt;1</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"作为构造函数调用\"><a href=\"#作为构造函数调用\" class=\"headerlink\" title=\"作为构造函数调用\"></a>作为构造函数调用</h3><p>JavaScript 支持面向对象式编程，与主流的面向对象式编程语言不同，JavaScript 并没有类（class）的概念，而是使用基于原型（prototype）的继承方式。相应的，JavaScript 中的构造函数也很特殊，如果不使用 new 调用，则和普通函数一样。作为又一项约定俗成的准则，构造函数以大写字母开头，提醒调用者使用正确的方式调用。如果调用正确，this 绑定到新创建的对象上。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x,y</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.x=x;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.y=y;</div><div class=\"line\">&#125;<span class=\"comment\">// this绑定到新创建的对象上。</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"使用apply和call调用（Function-prototype-上的-call-或者-apply-方法）\"><a href=\"#使用apply和call调用（Function-prototype-上的-call-或者-apply-方法）\" class=\"headerlink\" title=\"使用apply和call调用（Function.prototype 上的 call 或者 apply 方法）\"></a>使用apply和call调用（Function.prototype 上的 call 或者 apply 方法）</h3><p>让我们再一次重申，在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。很多 JavaScript 中的技巧以及类库都用到了该方法。让我们看一个具体的例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Point</span>(<span class=\"params\">x,y</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.x=x;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.y=y;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.moveTo=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.x=x;</div><div class=\"line\">\t\t<span class=\"keyword\">this</span>.y=y;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> p1=<span class=\"keyword\">new</span> Point(<span class=\"number\">0</span>,<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> p2=&#123;<span class=\"attr\">x</span>:<span class=\"number\">0</span>,<span class=\"attr\">y</span>:<span class=\"number\">0</span>&#125;;</div><div class=\"line\">p1.moveTo(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</div><div class=\"line\">p1.moveTo.apply(p2,[<span class=\"number\">10</span>,<span class=\"number\">10</span>]);</div></pre></td></tr></table></figure></p>\n<p>在上面的例子中，我们使用构造函数生成了一个对象 p1，该对象同时具有 moveTo 方法；使用对象字面量创建了另一个对象 p2，我们看到使用 apply 可以将 p1 的方法应用到 p2 上，这时候 this 也被绑定到对象 p2 上。另一个方法 call 也具备同样功能，不同的是最后的参数不是作为一个数组统一传入，而是分开传入的。<br>call和apply的理解可以参考我自己的github账号<a href=\"https://github.com/gruad\" target=\"_blank\" rel=\"external\">gruad</a></p>\n<h3 id=\"为什么javas中this的含义那么丰富\"><a href=\"#为什么javas中this的含义那么丰富\" class=\"headerlink\" title=\"为什么javas中this的含义那么丰富\"></a>为什么javas中this的含义那么丰富</h3><p>主要是javas中函数的执行环境和作用域链<br>JavaScript 中的函数既可以被当作普通函数执行，也可以作为对象的方法执行，这是导致 this 含义如此丰富的主要原因。一个函数被执行时，会创建一个执行环境（ExecutionContext），函数的所有的行为均发生在此执行环境中，构建该执行环境时，JavaScript 首先会创建 arguments变量，其中包含调用函数时传入的参数。接下来创建作用域链。然后初始化变量，首先初始化函数的形参表，值为 arguments变量中对应的值，如果 arguments变量中没有对应值，则该形参初始化为 undefined。如果该函数中含有内部函数，则初始化这些内部函数。如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为 undefined，其赋值操作在执行环境（ExecutionContext）创建成功后，函数执行时才会执行，这点对于我们理解 JavaScript 中的变量作用域非常重要，鉴于篇幅，我们先不在这里讨论这个话题。最后为 this变量赋值，如前所述，会根据函数调用方式的不同，赋给 this全局对象，当前对象等。至此函数的执行环境（ExecutionContext）创建成功，函数开始逐行执行，所需变量均从之前构建好的执行环境（ExecutionContext）中读取。</p>\n<h3 id=\"常见误解\"><a href=\"#常见误解\" class=\"headerlink\" title=\"常见误解\"></a>常见误解</h3><p>参考<a href=\"http://bonsaiden.github.io/JavaScript-Garden/zh/#function.this\" target=\"_blank\" rel=\"external\">js秘密花园</a><br>方法的赋值表达式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> test = someObject.methodTest;</div><div class=\"line\">test();<span class=\"comment\">// 上例中，test 就像一个普通的函数被调用；因此，函数内的 this 将不再被指向到 someObject 对象。</span></div></pre></td></tr></table></figure></p>\n<p>虽然 this 的晚绑定特性似乎并不友好，但这确实是基于原型继承赖以生存的土壤。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">Foo.prototype.method=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bar</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">Bar.prototype=Foo.prototype;</div><div class=\"line\"><span class=\"keyword\">new</span> Bar().method();<span class=\"comment\">// 当 method 被调用时，this 将会指向 Bar 的实例对象。</span></div></pre></td></tr></table></figure></p>\n<p>另外js秘密花园这门书理解的也很好<a href=\"http://bonsaiden.github.io/JavaScript-Garden/zh/#function.this\" target=\"_blank\" rel=\"external\">js秘密花园</a><br>阮一峰的简单但有语言上的点错误<a href=\"http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html\" target=\"_blank\" rel=\"external\">Javascript的this用法</a></p>\n","categories":["JavaScript"],"tags":["JavaScript闭包"]},{"title":"JavaScript中设计模式理解","url":"http://gruad.github.io/2017/08/08/JavaScript中设计模式理解/","content":"<h3 id=\"在JavaScript中什么是设计模式\"><a href=\"#在JavaScript中什么是设计模式\" class=\"headerlink\" title=\"在JavaScript中什么是设计模式\"></a>在JavaScript中什么是设计模式</h3><p>设计模式是指设计经验的总结，它的出现是为了可重用代码，保证代码的可靠性等。<br>JavaScript设计模式是面向对象编程的语言模式，和Java等面向对象的有相似性。</p>\n<h3 id=\"设计模式的分类\"><a href=\"#设计模式的分类\" class=\"headerlink\" title=\"设计模式的分类\"></a>设计模式的分类</h3><p>设计模式主要分三大类：</p>\n<ul>\n<li>1.创建型模式</li>\n<li>2.结构型模式</li>\n<li>3.行为型模式<br>额外的还有：技巧型模式和架构型模式。<h3 id=\"创建型设计模式\"><a href=\"#创建型设计模式\" class=\"headerlink\" title=\"创建型设计模式\"></a>创建型设计模式</h3>创建型设计模式是主要处理：类对象创建，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。创建型设计模式主要有简单工厂模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式和单例模式。<h3 id=\"简单工厂模式（实例待补充）\"><a href=\"#简单工厂模式（实例待补充）\" class=\"headerlink\" title=\"简单工厂模式（实例待补充）\"></a>简单工厂模式（实例待补充）</h3><h3 id=\"工厂模式（举例不是很理解）\"><a href=\"#工厂模式（举例不是很理解）\" class=\"headerlink\" title=\"工厂模式（举例不是很理解）\"></a>工厂模式（举例不是很理解）</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4>通过对产品的抽象使其创建业务主要负责用于创建多类产品的实例。<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4>在实际开发中，需求的变更是很正常的，开始需求简单可以直接创建对象，类似的需求多了可以用简单工厂方法重构，但是如果需求不停变化，那么不仅要修改工厂函数还要添加类，这样就没完了。而工厂方法模式本意是将实际创建对象的工作推迟到子类中。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 工厂类</span></div><div class=\"line\"><span class=\"keyword\">var</span> Factory=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type,content</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Factory)&#123;</div><div class=\"line\">\t\t<span class=\"comment\">// 这里的this我也不理解，this不应该是构造函数内的吗？所以它会指向实例化的对象啊。</span></div><div class=\"line\">\t\t<span class=\"keyword\">var</span> s=<span class=\"keyword\">new</span> <span class=\"keyword\">this</span>[type](content);</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> s;</div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 真心不理解</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Factory(type,content);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\">Factory.prototype=&#123;</div><div class=\"line\">\tJava:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//</span></div><div class=\"line\">&#125;,</div><div class=\"line\">\tJavaScript:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">content</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//</span></div><div class=\"line\">&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样以后如果想添加其他类，只需要在Factory的原型里添加就可以了。</p>\n<h3 id=\"原型模式（暂时没找到好的实例）\"><a href=\"#原型模式（暂时没找到好的实例）\" class=\"headerlink\" title=\"原型模式（暂时没找到好的实例）\"></a>原型模式（暂时没找到好的实例）</h3><h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><h4 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>又称为单体模式，只允许实例化一次的对象类。有时也可以用一个对象来规划一个命名空间，井井有条地管理对象上的属性和方法。</p>\n<h4 id=\"使用场景-1\"><a href=\"#使用场景-1\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><p>单例模式应该是JavaScript中最常见的一种设计模式了，经常为我们提供一个命名空间，来防止不同的人命名变量的冲突。还可以用它来创建一个小型的代码库。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> A=&#123;</div><div class=\"line\">\tUtil:&#123;</div><div class=\"line\">\tutil_method1:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</div><div class=\"line\">\tutil_method2:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</div><div class=\"line\">&#125;,</div><div class=\"line\">\tTool:&#123;</div><div class=\"line\">\ttool_method1:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</div><div class=\"line\">\ttool_method2:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">&#125;,</div><div class=\"line\">\tAjax:&#123;</div><div class=\"line\">\tajax_method1:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</div><div class=\"line\">\tajax_method2:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">\t...</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>如果想使用这个代码库，像下面这样访问即可：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">A.Util.util_method1();</div><div class=\"line\">A.Tool.tool_method2();</div></pre></td></tr></table></figure></p>\n<h4 id=\"收获与总结\"><a href=\"#收获与总结\" class=\"headerlink\" title=\"收获与总结\"></a>收获与总结</h4><p>它是只允许实例化一次的对象类，有时这么做也是为了节省系统资源。JavaScript中单例模式经常作为命名空间对象来实现，通过单例对象，我们可以将各个模块的代码井井有条地梳理在一起。<br>算了，今天就先总结到这里吧，下次在补充。。。</p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"http://hyuhan.com/2016/12/23/javascript-design-patterns/\" target=\"_blank\" rel=\"external\">主要贡献者</a></p>\n","categories":["JavaScript"],"tags":["JavaScript设计模式"]},{"title":"JavaScript中原型链理解","url":"http://gruad.github.io/2017/08/07/JavaScript中原型链理解/","content":"<p>关于原型链和JavaScript继承，我一直都是属于理解之后就忘得那种，可能是在开发过程中使用的少的原因。很快就忘了。我就不总结了，感觉没理解好，总结了也是白费。可以参考一下博文<a href=\"http://hyuhan.com/2016/08/28/JavaScript-prototype/\" target=\"_blank\" rel=\"external\">hyuhan</a>、<a href=\"http://cnodejs.org/topic/56e2d7488023c6146ec3ff05\" target=\"_blank\" rel=\"external\">cnodejs总结</a>、阮一峰的可以看它的来源<a href=\"http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html\" target=\"_blank\" rel=\"external\">Javascript继承机制的设计思想</a>和<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\" target=\"_blank\" rel=\"external\">MDN</a></p>\n","categories":["JavaScript"],"tags":["JavaScript原型链"]},{"title":"JavaScript中闭包的理解","url":"http://gruad.github.io/2017/08/07/JavaScript中闭包的理解/","content":"<p><strong> 今天抽空总结一下一直使用的闭包，个人理解，可能有所不足，还望包涵。 </strong><br>理解闭包，首先理解函数的生命周期<br>如图：<img src=\"/img/function.png\" alt=\"函数的生命周期\"></p>\n<h3 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h3><p>简单来说，就是指可以访问另一个函数作用域变量的函数（可以访问函数内部变量的函数），<br>一般是定义在外层函数中的内层函数。</p>\n<h3 id=\"为什么需要闭包？\"><a href=\"#为什么需要闭包？\" class=\"headerlink\" title=\"为什么需要闭包？\"></a>为什么需要闭包？</h3><p>局部变量无法长久的保存和共享，而全局变量可能造成变量污染，所以需要一种机制：可以长久的保存变量又不会污染全局变量</p>\n<h3 id=\"闭包的特点\"><a href=\"#闭包的特点\" class=\"headerlink\" title=\"闭包的特点\"></a>闭包的特点</h3><ul>\n<li>占用内存</li>\n<li>不容易释放<h3 id=\"闭包的理解实例\"><a href=\"#闭包的理解实例\" class=\"headerlink\" title=\"闭包的理解实例\"></a>闭包的理解实例</h3>设想下如果你想统计一些数值，且该计数器在所有函数中都是可用的。<br>你可以使用全局变量，函数设置计数器递增：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> counter=<span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> counter+=<span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">add();</div><div class=\"line\">add();</div><div class=\"line\">add();</div><div class=\"line\"><span class=\"comment\">// 计数器现在为 3</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>那么问题来了，页面上任何脚本都可以改变计数器，即使没有调用add函数。<br>下面我在函数内声明计数器，如果没有调用函数将无法修改计数器的值<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> counter=<span class=\"number\">0</span>;</div><div class=\"line\">\tcounter+=<span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">add();</div><div class=\"line\">add();</div><div class=\"line\">add();</div><div class=\"line\"><span class=\"comment\">// 本意是想输出 3, 但事与愿违，输出的都是 1 !</span></div></pre></td></tr></table></figure></p>\n<p>以上代码将无法正确输出，每次我调用 add() 函数，计数器都会设置为 1。<br>JavaScript 内嵌函数可以解决该问题。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> counter=<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">plus</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\tcounter+=<span class=\"number\">1</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tplus();</div><div class=\"line\">\t<span class=\"keyword\">return</span> counter;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果我们能在外部访问plus函数，这就可以解决计数器的困境。<br>我们同样需要确保counter=0只执行一次。<br>所以这个时候我们需要闭包。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> add=(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> counter=<span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> counter+=<span class=\"number\">1</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)();</div><div class=\"line\">add();</div><div class=\"line\">add();</div><div class=\"line\">add();</div><div class=\"line\"><span class=\"comment\">// 计数器为 3</span></div><div class=\"line\"><span class=\"comment\">// 理解这个一定要理解闭包的作用域链和函数的生命周期</span></div></pre></td></tr></table></figure></p>\n<p>实例解析：<br>变量 add 指定了函数自我调用的返回字值。<br>自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。<br>add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。<br>这个叫作 JavaScript 闭包。它使得函数拥有私有变量变成可能。<br>计数器受匿名函数的作用域保护，只能通过 add 方法修改。</p>\n<h3 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h3><ol>\n<li>匿名自执行函数</li>\n<li>结果缓存</li>\n<li>（封装）闭包可以用于在对象中创建私有变量<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> person=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//变量作用域为函数内部，外部无法访问 </span></div><div class=\"line\">\t<span class=\"keyword\">var</span> name=<span class=\"string\">\"default\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> &#123;</div><div class=\"line\">\t\tgetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> name;</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\tsetName:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newName</span>)</span>&#123;</div><div class=\"line\">\t\t\tname=newName;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;();</div><div class=\"line\">print(person.name);<span class=\"comment\">//直接访问，结果为undefined    </span></div><div class=\"line\">print(person.getName());    </div><div class=\"line\">person.setName(<span class=\"string\">\"abruzzi\"</span>);    </div><div class=\"line\">print(person.getName()); </div><div class=\"line\"><span class=\"comment\">// 得到结果如下：  </span></div><div class=\"line\">   </div><div class=\"line\"><span class=\"comment\">// undefined  </span></div><div class=\"line\"><span class=\"comment\">// default  </span></div><div class=\"line\"><span class=\"comment\">// abruzzi</span></div></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyObject</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 私有变量和私有方法</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> privateVariable=<span class=\"number\">10</span>;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">privateFunction</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"comment\">// 特有方法，调用私有方法，函数</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.publicMethod=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\tprivateVariable++;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> privateFunction();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>实现类与继承</li>\n<li>使用闭包可以在JavaScript中模拟块级作用域（ECMAScript6标准之前的JavaScript本身没有块级作用域的概念）<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outputNumbers</span>(<span class=\"params\">count</span>)</span>&#123;</div><div class=\"line\">\t(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;count;i++)&#123;</div><div class=\"line\">\talert(i);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t&#125;)();</div><div class=\"line\">\talert(i);<span class=\"comment\">// 将导致一个错误</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>其实没有实战，我还是有点不太明白，以后可以阅读这篇文章<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&amp;%20closures/ch5.md\" target=\"_blank\" rel=\"external\">you don’t know JS</a></p>\n<h3 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h3><p><a href=\"http://www.cnblogs.com/yunfeifei/p/4019504.html\" target=\"_blank\" rel=\"external\">大神博客理解闭包</a><br><a href=\"http://www.runoob.com/js/js-function-closures.html\" target=\"_blank\" rel=\"external\">菜鸟教程</a><br><a href=\"http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html\" target=\"_blank\" rel=\"external\">阮一峰闭包理解</a><br><a href=\"http://bonsaiden.github.io/JavaScript-Garden/zh/#function.closures\" target=\"_blank\" rel=\"external\">js秘密花园</a></p>\n","categories":["Javascript"],"tags":["Javascript闭包（closure）"]},{"title":"JavaScript作用域链理解","url":"http://gruad.github.io/2017/08/04/JavaScript作用域链理解/","content":"<p>之前读高性能JavaScript一书的理解，一直没有总结，今天总结一下作用域链。</p>\n<h3 id=\"作用域的影响\"><a href=\"#作用域的影响\" class=\"headerlink\" title=\"作用域的影响\"></a>作用域的影响</h3><p>从确定哪些变量可以被函数访问，到this的确定，JavaScript作用域也关系到性能，要理解速度与作用域的关系，首先要理解作用域的工作原理。</p>\n<h3 id=\"作用域链和标识符解析（Scope-Chains-and-Identifier-Resolution）\"><a href=\"#作用域链和标识符解析（Scope-Chains-and-Identifier-Resolution）\" class=\"headerlink\" title=\"作用域链和标识符解析（Scope Chains and Identifier Resolution）\"></a>作用域链和标识符解析（Scope Chains and Identifier Resolution）</h3><p>每个JavaScript函数都是一个对象，即一个函数对象实例。对象都拥有你可以编程访问的属性和内部属性，内部属性供JavaScript引擎使用，其中一个内部属性是：[[Scope]]，由 ECMA-262第三版标准定义。</p>\n<h3 id=\"作用域链和可变对象定义\"><a href=\"#作用域链和可变对象定义\" class=\"headerlink\" title=\"作用域链和可变对象定义\"></a>作用域链和可变对象定义</h3><ul>\n<li>The internal [[Scope]] property contains a collection of objects representing the scope in which the function was created. This collection is called the function’s scope chain and it determines the data that a function can access. * Each object in the function’s scope chain is called a variable object, and each of these contains entries for variables in the form of key-value pairs. When a function is created, its scope chain is populated with objects representing the data that is accessible in the scope in which the function was created.<br>函数的内部属性[Scope]包含一个集合——里面是对象，这个集合就是作用域链，可以决定哪些数据可由函数访问，<br>集合里的内一个对象叫——可变对象。当一个函数被创建后，集合开始填充对象。这些对象代表此函数中可以访问的数据。<br>比如全局函数：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">num1,num2</span>)</span>&#123;</div><div class=\"line\"><span class=\"keyword\">var</span> sum=num1+num2;</div><div class=\"line\"><span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>When the add() function is created, its scope chain is populated with a single variable object: the global object representing all of the variables that are globally defined. This global object contains entries for window, navigator, and document, to name a few.<br>如图：<img src=\"/img/chain.jpeg\" alt=\"add（）函数的作用域链\"><br>add函数的作用域链将会在运行时候用到。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> total=add(<span class=\"number\">5</span>,<span class=\"number\">10</span>);</div></pre></td></tr></table></figure></p>\n<h3 id=\"运行期上下文\"><a href=\"#运行期上下文\" class=\"headerlink\" title=\"运行期上下文\"></a>运行期上下文</h3><p>Executing the add function triggers the creation of an internal object called an execution context.运行add函数时将建立一个内部对象，称做“运行期上下文”，每次运行都将创建一个独一无二的“运行期上下文”，当函数运行完毕，运行期上下文销毁。An exe context defines the environment in which a function is being executed. Each execution context is unique to one particular execution of the function, and so multiple calls to the same function result in multiple execution contexts being created. The execution context is destroyed once the function has been completely executed.</p>\n<h3 id=\"活动对象\"><a href=\"#活动对象\" class=\"headerlink\" title=\"活动对象\"></a>活动对象</h3><p>一个运行期上下文有它自己的作用域链（对象集合），用于标识符解析。当运行期上下文被创建，作用域链被初始化，连同运行函数的[scope]属性中包含的对象。这些值按照他们在函数中出现的顺序，被复制到运行期上下文的作用域链中。<br>Once this is complete, a new object called the activation object is created for the execution context. The activation object acts as the variable object for this execution and contains entries for all local variables, named arguments, the arguments collection, and this. This object is then pushed to the front of the scope chain. When the execution context is destroyed, so is the activation object.<br>如图：<img src=\"/img/chain2.jpeg\" alt=\"运行add（）时的作用域链\"></p>\n<h3 id=\"函数运行过程作用域链的作用\"><a href=\"#函数运行过程作用域链的作用\" class=\"headerlink\" title=\"函数运行过程作用域链的作用\"></a>函数运行过程作用域链的作用</h3><p>在函数运行过程中，每遇到一个变量，标识符要决定从哪里获取和存储数据。此过程搜索运行期上下文的作用域链。搜索过程从运行函数的激活对象目标的作用域链的前端开始，如果找到了，就使用这个具体的标识符指定的变量。如果没有找到，这进入下一个作用域链的对象，此过程持续运行，知道标识符被找到。或者没有被找到。这种情况标识符被定义问未定义。正式这个过程，所以影响了性能。</p>\n<h3 id=\"改进方法与应用\"><a href=\"#改进方法与应用\" class=\"headerlink\" title=\"改进方法与应用\"></a>改进方法与应用</h3><ol>\n<li>少使用全局变量，尽量把全局变量存储在一个局部变量内。</li>\n<li>改变作用域链。</li>\n<li>动态作用域链</li>\n<li>闭包，作用域，内存。</li>\n</ol>\n","categories":["JavaScript"],"tags":["JavaScript作用域链"]},{"title":"webpack学习(一)","url":"http://gruad.github.io/2017/03/16/webpack学习笔记（一）/","content":"<p><a href=\"http://webpackdoc.com/\" target=\"_blank\" rel=\"external\">Webpack中文学习文档</a><br><a href=\"http://webpack.github.io/docs/\" target=\"_blank\" rel=\"external\">Webpack官方文档</a><br><a href=\"https://docs.npmjs.com/\" target=\"_blank\" rel=\"external\">npm文档</a><br><a href=\"http://es6.ruanyifeng.com/#docs/module\" target=\"_blank\" rel=\"external\">阮一峰ECMA6入门</a><br><a href=\"http://blog.csdn.net/kun5706947/article/details/52596766\" target=\"_blank\" rel=\"external\">参考博文</a><br><a href=\"https://segmentfault.com/a/1190000006968235\" target=\"_blank\" rel=\"external\">学习博文</a></p>\n<h3 id=\"1-什么是Webpack\"><a href=\"#1-什么是Webpack\" class=\"headerlink\" title=\"1. 什么是Webpack\"></a>1. 什么是Webpack</h3><p>Webpack是当下最热门的前端资源模块化（module)管理和打包（pack)工具。它可以将许多松散的模块按照<strong>依赖</strong>和规则打包成符合生产环境部署的前端资源。&gt; 还可以将<strong>按需加载</strong>的模块进行代码分离。等到实际需要的时候在<strong>异步加载</strong>。</p>\n<blockquote>\n<p>通过loader的转换，任何形式的资源都可以视作模块，比如CommonJs模块、AMD模块、ES6模块、CSS、图片、JSON、Coffeescript、LESS等。</p>\n</blockquote>\n<h3 id=\"2-模块系统功能\"><a href=\"#2-模块系统功能\" class=\"headerlink\" title=\"2. 模块系统功能\"></a>2. 模块系统功能</h3><blockquote>\n<p>模块系统主要解决模块的定义、依赖、导出。</p>\n</blockquote>\n<h3 id=\"3-普通的以script方式引入模块存在的问题\"><a href=\"#3-普通的以script方式引入模块存在的问题\" class=\"headerlink\" title=\"3. 普通的以script方式引入模块存在的问题\"></a>3. 普通的以script方式引入模块存在的问题</h3><ol>\n<li>全局作用域下容易造成变量的冲突。</li>\n<li>文件只能按照script的书写顺序进行加载。</li>\n<li>开发人员<strong>必须主观</strong>解决模块和代码库的<strong>依赖关系</strong>。</li>\n<li>在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪，难以维护。</li>\n</ol>\n<h3 id=\"4-CommonJS方式思想和问题\"><a href=\"#4-CommonJS方式思想和问题\" class=\"headerlink\" title=\"4. CommonJS方式思想和问题\"></a>4. CommonJS方式思想和问题</h3><p>服务器端的NodeJS遵循CommonJS规范，该规范的核心思想：</p>\n<blockquote>\n<p>允许模块通过require方式来<strong>同步加载</strong>所需要的依赖的其他模块，然后通过exports或module.exports来导出需要暴露的接口。</p>\n</blockquote>\n<p>优点：</p>\n<ol>\n<li>服务器端模块便于重用</li>\n<li>NPM 中已经有将近20万个可以使用模块包</li>\n<li>简单并容易使用</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>同步的模块加载方式不适合在浏览器环境中，同步意味着<strong>阻塞加载</strong>，<strong>浏览器资源是异步加载</strong>的</li>\n<li>不能<strong>非阻塞的并行加载</strong>多个模块</li>\n</ol>\n<h3 id=\"5-AMD\"><a href=\"#5-AMD\" class=\"headerlink\" title=\"5. AMD\"></a>5. AMD</h3><p>Asynchronous Module Definition 规范其实只有一个主要的接口define（id?,dependencies?,factory)，它要在声明模块的时候指定所有的依赖dependencies,并且还要当做形参传到factory中，对于依赖的模块提前执行，提前前置。</p>\n<p>优点：</p>\n<ol>\n<li>适合在浏览器环境中异步加载模块</li>\n<li>可以并行加载多个模块</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅</li>\n<li>不符合通用的模块化思维方式，是一种妥协的实现</li>\n</ol>\n<p>实现：</p>\n<p>RequireJS<br>curl</p>\n<h3 id=\"6-CMD\"><a href=\"#6-CMD\" class=\"headerlink\" title=\"6. CMD\"></a>6. CMD</h3><p>Common Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">'jquery'</span>);</div><div class=\"line\">  <span class=\"keyword\">var</span> Spinning = <span class=\"built_in\">require</span>(<span class=\"string\">'./spinning'</span>);</div><div class=\"line\">  exports.doSomething = ...</div><div class=\"line\">  <span class=\"built_in\">module</span>.exports = ...</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>优点：</p>\n<ol>\n<li>依赖就近，延迟执行</li>\n<li>可以很容易在 Node.js 中运行</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>依赖 SPM 打包，模块的加载逻辑偏重</li>\n</ol>\n<p>实现：</p>\n<p>Sea.js<br>coolie</p>\n<h3 id=\"7-Webpack中蕴含的思想\"><a href=\"#7-Webpack中蕴含的思想\" class=\"headerlink\" title=\"7. Webpack中蕴含的思想\"></a>7. Webpack中蕴含的思想</h3><ol>\n<li><p>前端模块加载方式：<strong>分块传输</strong>，按需进行<strong>懒加载</strong>，在实际用到某些模块的时候再<strong>增量更新</strong>，才是较为合理的模块加载方案。<br>要实现模块的按需加载，就需要一个对整个代码库中的模块进行静态分析、编译打包的过程。</p>\n<blockquote>\n<p>在编译的时候，要对整个代码进行静态分析，分析出各个模块的类型和它们依赖关系，然后将不同类型的模块提交给适配的加载器来处理。</p>\n</blockquote>\n</li>\n<li><p>Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到 bundle.js 。Webpack 会给每个模块<strong>分配一个唯一的 id 并通过这个 id 索引和访问模块</strong>。在页面启动时，会先执行 entry.js 中的代码，其它模块会在运行 require 的时候再执行。</p>\n</li>\n</ol>\n<h3 id=\"8-Webpack的特点\"><a href=\"#8-Webpack的特点\" class=\"headerlink\" title=\"8. Webpack的特点\"></a>8. Webpack的特点</h3><h6 id=\"Webpack和其他模块化工具有什么区别呢？\"><a href=\"#Webpack和其他模块化工具有什么区别呢？\" class=\"headerlink\" title=\"Webpack和其他模块化工具有什么区别呢？\"></a>Webpack和其他模块化工具有什么区别呢？</h6><h6 id=\"代码拆分\"><a href=\"#代码拆分\" class=\"headerlink\" title=\"代码拆分\"></a>代码拆分</h6><p>Webpack 有两种组织模块依赖的方式，同步和异步。<strong>异步依赖作为分割点</strong>，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。</p>\n<h6 id=\"Loader\"><a href=\"#Loader\" class=\"headerlink\" title=\"Loader\"></a>Loader</h6><p>Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。</p>\n<h6 id=\"智能解析\"><a href=\"#智能解析\" class=\"headerlink\" title=\"智能解析\"></a>智能解析</h6><p>Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 require(“./templates/“ + name + “.jade”)。</p>\n<h6 id=\"插件系统\"><a href=\"#插件系统\" class=\"headerlink\" title=\"插件系统\"></a>插件系统</h6><p>Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。</p>\n<h6 id=\"快速运行\"><a href=\"#快速运行\" class=\"headerlink\" title=\"快速运行\"></a>快速运行</h6><p>Webpack 使用<strong>异步 I/O</strong> 和<strong>多级缓存</strong>提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。</p>\n<p>未完待续…持续更新中</p>\n","categories":["Webpack"],"tags":["打包Webpack 模块化管理module"]},{"title":"究竟要行过多少路，做过什么事，才能做起来毫不费力和开心","url":"http://gruad.github.io/2017/03/08/究竟要行过多少路，做过什么事，才能做起来毫不费力、开心/","content":"","categories":["随笔"],"tags":["心情"]},{"title":"前端各种高度宽度总结-持续积累更新中","url":"http://gruad.github.io/2017/03/08/前端各种高度宽度总结-持续积累更新中/","content":"<p><img src=\"/img/123.png\" alt=\"\"><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">1.</span> <span class=\"built_in\">document</span>.body.offsetWidth\t网页可见区域宽度（包括滚动条和边框）</div><div class=\"line\"><span class=\"number\">2.</span> <span class=\"built_in\">document</span>.body.scrollWidth    网页正文全文宽度</div><div class=\"line\"><span class=\"number\">3.</span> <span class=\"built_in\">document</span>.body.clientWidth    网页可见区域宽度</div><div class=\"line\"><span class=\"number\">4.</span> <span class=\"built_in\">document</span>.body.scrollTop\t<span class=\"built_in\">document</span>.documentElement.scrollTop (IE)\t网页被卷去的高度</div><div class=\"line\"><span class=\"number\">5.</span> <span class=\"built_in\">document</span>.body.scrollLeft  \t网页被卷去的左</div><div class=\"line\"><span class=\"number\">6.</span> <span class=\"built_in\">window</span>.sreenTop \t\t\t\t网页正文部分上</div><div class=\"line\"><span class=\"number\">7.</span> <span class=\"built_in\">window</span>.screenLeft\t\t\t网页正文部分左</div><div class=\"line\"><span class=\"number\">8.</span> obj.offsetWidth \t\t\t\t某个元素的宽</div><div class=\"line\"><span class=\"number\">9.</span> \t某个元素的上边界到body最顶部的距离：obj.offsetTop;（在元素的包含元素不含滚动条的情况下）</div><div class=\"line\"><span class=\"number\">10.</span> 某个元素的左边界到body最左边的距离：obj.offsetLeft;（在元素的包含元素不含滚动条的情况下）</div><div class=\"line\"><span class=\"number\">11.</span> 返回当前元素的上边界到它的包含元素的上边界的偏移量：obj.offsetTop（在元素的包含元素含滚动条的情况下）</div><div class=\"line\"><span class=\"number\">12.</span> 返回当前元素的左边界到它的包含元素的左边界的偏移量：obj.offsetLeft（在元素的包含元素含滚动条的情况下）</div></pre></td></tr></table></figure></p>\n","categories":["基础积累"],"tags":["基础"]},{"title":"JavaScript实现加载效果与实际应用","url":"http://gruad.github.io/2017/03/08/JavaScript实现加载效果与实际应用/","content":"<h3 id=\"1-背景\"><a href=\"#1-背景\" class=\"headerlink\" title=\"1. 背景\"></a>1. 背景</h3><p>最近实习在做一个项目，需求：需要在一个页面点击按钮加载出包括表格和几张图表（图表为ajax动态请求数据和highchart画出）<br>所以需要等待加载状态，提示用户正在加载，增强用户交互体验和友好度。<br>类似效果：<br><img src=\"/img/loading.png\" alt=\"\"></p>\n<h3 id=\"2-实现过程\"><a href=\"#2-实现过程\" class=\"headerlink\" title=\"2. 实现过程\"></a>2. 实现过程</h3><p>实现一个加载效果不难，重要的是要把页面中每个的图表都加上加载效果，需要考虑每个图表的高度（不同）和宽度，还有初始化显示的位置。<br>代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// showMask</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">showMask</span>(<span class=\"params\">n</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// 每个container图表的顶部距离body的高度</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> top = $(<span class=\"string\">\"#container\"</span> + n).offset().top;</div><div class=\"line\">\t<span class=\"comment\">// 每个container图表的高度</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> height = $(<span class=\"string\">\"#container\"</span> + n).height();</div><div class=\"line\">\t<span class=\"comment\">// 定义mask遮蔽层并初始化</span></div><div class=\"line\">\t<span class=\"keyword\">var</span> mask = $(<span class=\"string\">'&lt;div id=\"mask'</span> + n + <span class=\"string\">'\"&gt;&lt;/div&gt;'</span>).css(&#123;</div><div class=\"line\">\t\tdisplay : <span class=\"string\">\"block\"</span>,</div><div class=\"line\">\t\tposition : <span class=\"string\">\"absolute\"</span>,</div><div class=\"line\">\t\tbackground : <span class=\"string\">\"#F2F2F2\"</span>,</div><div class=\"line\">\t\topacity:<span class=\"number\">0.4</span>,</div><div class=\"line\">\t\twidth : <span class=\"string\">\"100%\"</span>,</div><div class=\"line\">\t\theight : height,</div><div class=\"line\">\t\ttop : top</div><div class=\"line\">\t&#125;).appendTo($(<span class=\"string\">\"body\"</span>));</div><div class=\"line\">\t<span class=\"comment\">// 定义加载提示信息并初始化</span></div><div class=\"line\">\t$(<span class=\"string\">'&lt;div id=\"msg'</span> + n + <span class=\"string\">'\"&gt;&lt;/div&gt;'</span>)</div><div class=\"line\">\t\t\t.html(<span class=\"string\">\"&lt;i class='fa fa-spinner fa-spin'&gt;&lt;/i&gt;&lt;span id='span1'&gt;正在处理，请稍候。。。&lt;/span&gt;\"</span>)</div><div class=\"line\">\t\t\t.appendTo($(<span class=\"string\">\"body\"</span>)).css(&#123;</div><div class=\"line\">\t\t\t\tdisplay : <span class=\"string\">\"block\"</span>,</div><div class=\"line\">\t\t\t\tposition : <span class=\"string\">\"absolute\"</span>,</div><div class=\"line\">\t\t\t\t<span class=\"string\">'font-size'</span> : <span class=\"string\">\"16px\"</span>,</div><div class=\"line\">\t\t\t\tleft : $(<span class=\"string\">\"#mask\"</span> + n).width() / <span class=\"number\">2</span> - $(<span class=\"string\">\"#span1\"</span>).width() / <span class=\"number\">2</span>,</div><div class=\"line\">\t\t\t\ttop : top + $(<span class=\"string\">\"#mask\"</span> + n).height() / <span class=\"number\">2</span></div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-效果\"><a href=\"#3-效果\" class=\"headerlink\" title=\"3. 效果\"></a>3. 效果</h3><p><img src=\"/img/loading1.jpg\" alt=\"\"></p>\n","categories":["携程实习"],"tags":["加载效果"]},{"title":"JavaScript实现数组去重","url":"http://gruad.github.io/2017/03/03/JavaScript实现数组去重/","content":"<h3 id=\"1-背景\"><a href=\"#1-背景\" class=\"headerlink\" title=\"1. 背景\"></a>1. 背景</h3><p>数组去重的方法网上有很多，至少有五种之多，具体可查阅百度。<br>因为最近自己在做项目，需要写一个省市区的联动选择控件，所以需要用到去重，于是自己就思考着写了一个。</p>\n<h3 id=\"2-源码\"><a href=\"#2-源码\" class=\"headerlink\" title=\"2. 源码\"></a>2. 源码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">uniqueArray</span>(<span class=\"params\">array</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> arr=[];</div><div class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>,len=array.length;i&lt;len;i++)&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j=i+<span class=\"number\">1</span>;j&lt;len;j++)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(array[i]===array[j])</div><div class=\"line\">\t\tj=++i;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tarr.push(array[i]);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> arr</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-源码截图\"><a href=\"#3-源码截图\" class=\"headerlink\" title=\"3. 源码截图\"></a>3. 源码截图</h3><p><img src=\"/img/unique1.png\" alt=\"\"></p>\n<h3 id=\"4-测试数组\"><a href=\"#4-测试数组\" class=\"headerlink\" title=\"4. 测试数组\"></a>4. 测试数组</h3><p><img src=\"/img/unique2.png\" alt=\"\"></p>\n<h3 id=\"5-运行结果\"><a href=\"#5-运行结果\" class=\"headerlink\" title=\"5. 运行结果\"></a>5. 运行结果</h3><p><img src=\"/img/unique3.png\" alt=\"\"></p>\n","categories":["算法"],"tags":["数组去重"]},{"title":"Vue.js学习笔记（一）","url":"http://gruad.github.io/2017/02/16/Vue-js学习笔记(一)/","content":"<h3 id=\"常见的标签指令含义\"><a href=\"#常见的标签指令含义\" class=\"headerlink\" title=\"常见的标签指令含义\"></a>常见的标签指令含义</h3><ol>\n<li>v-bind<br>简写：:id=”message”<br>绑定标签属性的</li>\n<li>v-model<br>双向数据绑定的</li>\n<li>v-for<br>列表渲染用的</li>\n<li>v-if<br>条件渲染用的</li>\n<li>v-on<br>简写：@click=”method”<br>绑定事件的</li>\n</ol>\n","categories":["Vue.js"],"tags":["Vue.js"]},{"title":"Jquery的attr()函数和prop()和val()和html()和text()和css()函数比较","url":"http://gruad.github.io/2017/02/09/Jquery的attr-函数和val-函数和css-函数比较/","content":"","categories":["技术基础"],"tags":["jquery"]},{"title":"bootstrap table 学习与实践","url":"http://gruad.github.io/2017/02/07/bootstrap-table-学习与实践/","content":"<h3 id=\"1-bootstrap-table学习参考文档地址\"><a href=\"#1-bootstrap-table学习参考文档地址\" class=\"headerlink\" title=\"1. bootstrap-table学习参考文档地址\"></a>1. bootstrap-table学习参考文档地址</h3><p><a href=\"http://bootstrap-table.wenzhixin.net.cn/documentation/\" target=\"_blank\" rel=\"external\">bootstrap-table官方英文文档</a><br><a href=\"http://bootstrap-table.wenzhixin.net.cn/zh-cn/documentation/\" target=\"_blank\" rel=\"external\">bootstrap-table官方中文文档</a><br><a href=\"https://github.com/wenzhixin/bootstrap-table/\" target=\"_blank\" rel=\"external\">bootstrap-table的github文档</a></p>\n<h3 id=\"2-引入依赖的资源文件\"><a href=\"#2-引入依赖的资源文件\" class=\"headerlink\" title=\"2. 引入依赖的资源文件\"></a>2. 引入依赖的资源文件</h3><p><img src=\"/img/bootstrap1.png\" alt=\"\"></p>\n<h3 id=\"3-有两种table构建方式\"><a href=\"#3-有两种table构建方式\" class=\"headerlink\" title=\"3. 有两种table构建方式\"></a>3. 有两种table构建方式</h3><p>3.1 代码写好表头</p>\n<blockquote>\n<p>思路是前端布局好格式(包括表头结构)，后端用异步请求获取数据，填充表格</p>\n</blockquote>\n<p>方式一：如下图<br><img src=\"/img/bootstrap2.png\" alt=\"\"></p>\n<p>前端代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;table id=<span class=\"string\">\"table\"</span></div><div class=\"line\">\t data-toggle=<span class=\"string\">\"table\"</span></div><div class=\"line\">\t data-toolbar=<span class=\"string\">\"#toolbar\"</span></div><div class=\"line\">\t data-pagination=<span class=\"string\">\"true\"</span> </div><div class=\"line\">\t data-search=<span class=\"string\">\"true\"</span> </div><div class=\"line\">\t data-row-style=<span class=\"string\">\"rowStyle\"</span></div><div class=\"line\">\t data-filter-control=<span class=\"string\">\"true\"</span></div><div class=\"line\">\t data-filter-show-clear=<span class=\"string\">\"true\"</span> </div><div class=\"line\">\t data-show-pagination-<span class=\"keyword\">switch</span>=<span class=\"string\">\"true\"</span></div><div class=\"line\">\t data-detail-view=<span class=\"literal\">true</span></div><div class=\"line\">\t data-detail-formatter=<span class=\"string\">\"detailFormatter\"</span></div><div class=\"line\">\t data-row-style=<span class=\"string\">\"rowStyle\"</span>&gt;</div><div class=\"line\">\t\t&lt;thead&gt;</div><div class=\"line\">\t\t\t&lt;tr&gt;</div><div class=\"line\">\t\t\t\t&lt;th data-formatter=<span class=\"string\">\"runningFormatter\"</span> data-align=<span class=\"string\">\"center\"</span>&gt;&lt;/th&gt;</div><div class=\"line\">\t\t\t\t&lt;th data-field=<span class=\"string\">\"P_Id\"</span> data-visible=<span class=\"string\">\"false\"</span>&gt;ID&lt;<span class=\"regexp\">/th&gt;</span></div><div class=\"line\"><span class=\"regexp\">\t\t\t\t&lt;th data-field=\"SubjectSort\" data-sortable=\"true\"&gt;文本&lt;/</span>th&gt;</div><div class=\"line\">\t\t\t\t&lt;th data-field=<span class=\"string\">\"Subject\"</span> data-sortable=<span class=\"string\">\"true\"</span>data-filter-control=<span class=\"string\">\"select\"</span>&gt;文本&lt;<span class=\"regexp\">/th&gt;</span></div><div class=\"line\"><span class=\"regexp\">\t\t\t\t&lt;th data-field=\"Remarks\" data-sortable=\"true\" data-formatter=\"remarksFormatter\"&gt;文本&lt;/</span>th&gt;</div><div class=\"line\">\t\t\t\t&lt;th data-field=<span class=\"string\">\"Author\"</span> data-sortable=<span class=\"string\">\"true\"</span> data-filter-control=<span class=\"string\">\"select\"</span>&gt;文本&lt;<span class=\"regexp\">/th&gt;</span></div><div class=\"line\"><span class=\"regexp\">\t\t\t    &lt;th data-field=\"Tag\" data-sortable=\"true\" data-formatter=\"tagsFormatter\" data-filter-control=\"input\" data-events=\"tagsEvents\"&gt;文本&lt;/</span>th&gt;</div><div class=\"line\">\t\t\t\t&lt;th data-field=<span class=\"string\">\"Attachment\"</span> data-formatter=<span class=\"string\">\"attachmentFormatter\"</span></div><div class=\"line\">\t\t\t\t\tdata-align=<span class=\"string\">\"center\"</span>&gt;文本&lt;<span class=\"regexp\">/th&gt;</span></div><div class=\"line\"><span class=\"regexp\">\t\t\t\t&lt;th data-field=\"CreateDT\" data-sortable=\"true\" data-width=\"160px\"&gt;文本&lt;/</span>th&gt;</div><div class=\"line\">\t\t\t\t&lt;th data-field=<span class=\"string\">\"UpdatedDT\"</span> data-sortable=<span class=\"string\">\"true\"</span> data-width=<span class=\"string\">\"160px\"</span>&gt;文本&lt;<span class=\"regexp\">/th&gt;</span></div><div class=\"line\"><span class=\"regexp\">\t\t\t&lt;/</span>tr&gt;</div><div class=\"line\">\t\t&lt;<span class=\"regexp\">/thead&gt;</span></div><div class=\"line\"><span class=\"regexp\">&lt;/</span>table&gt;</div></pre></td></tr></table></figure></p>\n<p>js代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//异步请求获取数据，填充表格\t</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMemos</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t$.ajax(&#123;</div><div class=\"line\">\t\ttype : <span class=\"string\">\"GET\"</span>,</div><div class=\"line\">\t\tasyn : <span class=\"literal\">true</span>,</div><div class=\"line\">\t\turl : <span class=\"string\">\"&lt;c:url value='/getMemos'/&gt;\"</span> + <span class=\"string\">\"?date=\"</span></div><div class=\"line\">\t\t\t\t+ <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime(),</div><div class=\"line\">\t\tsuccess : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">datas</span>) </span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">var</span> data = datas.rows;</div><div class=\"line\">\t\t\t$(<span class=\"string\">'#table'</span>).bootstrapTable(<span class=\"string\">'load'</span>, data);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行结果<br><img src=\"/img/bootstrap3.png\" alt=\"\"></p>\n<p>3.2 无表头，自动构建表头</p>\n<blockquote>\n<p>思路是前端只定义表格，后端用异步请求获取数据，构造表格结构和填充表格</p>\n</blockquote>\n<p>方式二：如下图<br><img src=\"/img/bootstrap4.png\" alt=\"\"></p>\n<p>前端代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;table id=<span class=\"string\">\"table\"</span></div><div class=\"line\">\t   data-toggle=<span class=\"string\">\"table\"</span></div><div class=\"line\">\t   data-toolbar=<span class=\"string\">\"#toolbar\"</span></div><div class=\"line\">\t   data-pagination=<span class=\"string\">\"true\"</span></div><div class=\"line\">\t   data-page-size=<span class=\"string\">\"20\"</span></div><div class=\"line\">\t   data-row-style=<span class=\"string\">\"rowStyle\"</span></div><div class=\"line\">\t   data-<span class=\"literal\">undefined</span>-text=<span class=\"string\">\"\"</span></div><div class=\"line\">       data-show-<span class=\"keyword\">export</span>=<span class=\"string\">\"true\"</span>&gt;</div><div class=\"line\">&lt;<span class=\"regexp\">/table&gt;</span></div></pre></td></tr></table></figure></p>\n<p>js代码<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getHeaderAndData</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t</div><div class=\"line\">    $.ajax(&#123;</div><div class=\"line\">        type: <span class=\"string\">\"POST\"</span>,</div><div class=\"line\">        url: <span class=\"string\">\"../headerAndData/groupPriceMapping\"</span> + <span class=\"string\">\"?date=\"</span> + <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime(),</div><div class=\"line\">        data: &#123;</div><div class=\"line\">            start_dt: start_dt,</div><div class=\"line\">            end_dt: end_dt</div><div class=\"line\">        &#125;,  </div><div class=\"line\">        beforeSend: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">xhr</span>) </span>&#123;</div><div class=\"line\">            xhr.setRequestHeader(header, token);</div><div class=\"line\">        &#125;,</div><div class=\"line\">        success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">datas</span>) </span>&#123;</div><div class=\"line\">        \t<span class=\"built_in\">console</span>.log(datas);</div><div class=\"line\">            <span class=\"keyword\">var</span> data = datas.data[<span class=\"number\">0</span>].rows;</div><div class=\"line\">            datas.columns.unshift(&#123;</div><div class=\"line\">    \t\t\t    field : <span class=\"string\">'Index'</span>,</div><div class=\"line\">    \t\t\t    title : <span class=\"string\">'序号'</span>,</div><div class=\"line\">    \t\t\t    sortable : <span class=\"literal\">true</span></div><div class=\"line\">    \t\t\t&#125;);</div><div class=\"line\">    \t\t<span class=\"comment\">//console.log(datas.columns);</span></div><div class=\"line\">    \t\t    $.each(data, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">index, obj</span>) </span>&#123;   \t\t</div><div class=\"line\">    \t\t\t\tdata[index].Index=index+<span class=\"number\">1</span>;</div><div class=\"line\">    \t\t    &#125;);</div><div class=\"line\">    \t\t<span class=\"comment\">//console.log(data);</span></div><div class=\"line\">            $(<span class=\"string\">'#table'</span>).bootstrapTable(<span class=\"string\">'destroy'</span>).bootstrapTable(&#123;</div><div class=\"line\">    \t\t\tcolumns : datas.columns,</div><div class=\"line\">    \t\t\tdata : data</div><div class=\"line\">    \t\t    &#125;);            </div><div class=\"line\">        &#125;,</div><div class=\"line\">    \terror : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">xhr, status, e</span>) </span>&#123;</div><div class=\"line\">\t\t\t$.messager.alert(<span class=\"string\">'Alert'</span>,status,<span class=\"string\">'error'</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行结果<br><img src=\"/img/bootstrap5.png\" alt=\"\"></p>\n<h3 id=\"4-bootstrap-table简单学习，后续持续更新\"><a href=\"#4-bootstrap-table简单学习，后续持续更新\" class=\"headerlink\" title=\"4. bootstrap-table简单学习，后续持续更新\"></a>4. bootstrap-table简单学习，后续持续更新</h3><p>原创内容，欢迎学习和交流</p>\n","categories":["携程实习"],"tags":["bootstrap-table"]},{"title":"bootstrap-table中data-row-style的实战应用","url":"http://gruad.github.io/2017/02/06/bootstrap-table中data-row-style的实战应用/","content":"<h3 id=\"1-bootstrap-table的table代码\"><a href=\"#1-bootstrap-table的table代码\" class=\"headerlink\" title=\"1. bootstrap-table的table代码\"></a>1. bootstrap-table的table代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;table id=<span class=\"string\">\"table\"</span> </div><div class=\"line\">\tdata-toggle=<span class=\"string\">\"table\"</span></div><div class=\"line\">   \tdata-toolbar=<span class=\"string\">\"#toolbar\"</span></div><div class=\"line\">\tdata-pagination=<span class=\"string\">\"true\"</span></div><div class=\"line\">\tdata-row-style=<span class=\"string\">\"rowStyle\"</span></div><div class=\"line\">    data-show-<span class=\"keyword\">export</span>=<span class=\"string\">\"true\"</span></div><div class=\"line\">    data-show-pagination-<span class=\"keyword\">switch</span>=<span class=\"string\">\"true\"</span>\t&gt;</div><div class=\"line\">    ...省略代码</div><div class=\"line\">&lt;<span class=\"regexp\">/table&gt;</span></div></pre></td></tr></table></figure>\n<h3 id=\"2-rowStyle代码\"><a href=\"#2-rowStyle代码\" class=\"headerlink\" title=\"2. rowStyle代码\"></a>2. rowStyle代码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rowStyle</span>(<span class=\"params\">row, style</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        css: &#123;</div><div class=\"line\">            <span class=\"string\">\"font-size\"</span>: <span class=\"string\">\"14px\"</span>,</div><div class=\"line\">            <span class=\"string\">\"white-space\"</span>:<span class=\"string\">\"nowrap\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-运行结果\"><a href=\"#3-运行结果\" class=\"headerlink\" title=\"3. 运行结果\"></a>3. 运行结果</h3><p><img src=\"/img/bootstraptable.png\" alt=\"\"></p>\n","categories":["bootstrap"],"tags":["bootstrap-table"]},{"title":"selenium中webdriver中父标签的width=0和height=0，子标签无法操作的个人理解","url":"http://gruad.github.io/2017/02/03/selenium中webdriver中父标签的width-0和height-0，子标签无法操作的个人理解/","content":"<ul>\n<li>个人原创，全是实践的结果，欢迎阅读 </li>\n</ul>\n<h3 id=\"1-当class-plugin-modal-dialog的标签width-0和height-0的时候，使用cssSelector方法是无法找到它所包含的字标签的。所以无法操作，提示错误：element-is-unvisible\"><a href=\"#1-当class-plugin-modal-dialog的标签width-0和height-0的时候，使用cssSelector方法是无法找到它所包含的字标签的。所以无法操作，提示错误：element-is-unvisible\" class=\"headerlink\" title=\"1. 当class=plugin-modal-dialog的标签width=0和height=0的时候，使用cssSelector方法是无法找到它所包含的字标签的。所以无法操作，提示错误：element is unvisible\"></a>1. 当class=plugin-modal-dialog的标签width=0和height=0的时候，使用cssSelector方法是无法找到它所包含的字标签的。所以无法操作，提示错误：element is unvisible</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/2101255-0859fbfb81ad6d79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"2-查阅资料，问题可能原因-解决思路有两种\"><a href=\"#2-查阅资料，问题可能原因-解决思路有两种\" class=\"headerlink\" title=\"2. 查阅资料，问题可能原因  解决思路有两种\"></a>2. 查阅资料，<a href=\"http://www.51testing.com/html/91/79191-829759.html\" target=\"_blank\" rel=\"external\">问题可能原因</a>  解决思路有两种</h3><p><strong> 一 </strong>在webdriver中运行javascript代码，修改相应父标签的属性width和height<br><strong> 二 </strong>既然width=0的标签可以选择到，那么是否可以根据父元素递归找到子元素，进行操作。</p>\n<h3 id=\"根据上述思路一，解决问题步骤\"><a href=\"#根据上述思路一，解决问题步骤\" class=\"headerlink\" title=\"根据上述思路一，解决问题步骤\"></a>根据上述思路一，解决问题步骤</h3><blockquote>\n<ol>\n<li>webdriver中运行javascript代码方法：<a href=\"http://lijingshou.iteye.com/blog/2018929\" target=\"_blank\" rel=\"external\">参考链接</a></li>\n</ol>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2101255-3858d2826c4d45fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<ol>\n<li>运行结果，显示成功</li>\n</ol>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2101255-b6b7fad411bd1912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<ol>\n<li>修改成功后，再次运行cssSelector方法，之后操作并不成功。</li>\n</ol>\n</blockquote>\n<h3 id=\"根据上述思路二，解决问题步骤\"><a href=\"#根据上述思路二，解决问题步骤\" class=\"headerlink\" title=\"根据上述思路二，解决问题步骤\"></a>根据上述思路二，解决问题步骤</h3><blockquote>\n<ol>\n<li>首先父元素可以获取到，如下图</li>\n</ol>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2101255-14e9466c8d2f7259.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>运行结果：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2101255-d8f2c1ba7b7dc4c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<ol>\n<li>根据可以获得父元素，递归找到子元素（尝试）<br>2.1 首先获取父元素</li>\n</ol>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2101255-72548b1dfe2a07d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>2.2 然后递归获取子元素</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2101255-c53ed4517347c99b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>2.3 运行结果，显示获取成功，所以可以成功操作父元素的width=0和height=0时候，子元素无法获取的问题。</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2101255-fb624a63e71a012d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n","categories":["百度实习"],"tags":["java 自动化测试 前端测试"]},{"title":"JavaScript实现快速排序算法的最佳实践","url":"http://gruad.github.io/2017/01/26/JavaScript实现快速排序算法的最佳实践/","content":"<h1 id=\"1-快速排序的基本思想\"><a href=\"#1-快速排序的基本思想\" class=\"headerlink\" title=\"1. 快速排序的基本思想\"></a>1. 快速排序的基本思想</h1><p>长话短说，排序算法中快速排序的性能还是不错的，今天我就讲讲javascript中实现快速排序算法。</p>\n<blockquote>\n<p>它的基本思想是：，选择一个基准，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以<a href=\"http://baike.baidu.com/view/96473.htm\" target=\"_blank\" rel=\"external\">递归</a>进行，以此达到整个数据变成有序<a href=\"http://baike.baidu.com/subview/71968/12546268.htm\" target=\"_blank\" rel=\"external\">序列</a>。</p>\n</blockquote>\n<h1 id=\"2-JavaScript的实现代码\"><a href=\"#2-JavaScript的实现代码\" class=\"headerlink\" title=\"2. JavaScript的实现代码\"></a>2. JavaScript的实现代码</h1><p>我觉得这段程序完美的诠释了算法思想和算法实践》堪称完美<br>另外附上测试数组加结果截图。</p>\n<blockquote>\n<p>个人代码实践截图<br><img src=\"http://upload-images.jianshu.io/upload_images/2101255-3eee152b124ea7f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<p>—————————–原文是我的简书博客：<a href=\"http://www.jianshu.com/p/345f12016a1f\" target=\"_blank\" rel=\"external\">我的简书博客</a></p>\n","categories":["算法"],"tags":["快速排序"]},{"title":"从玩魔方看我的学习思维","url":"http://gruad.github.io/2017/01/26/从玩魔方看学习思维/","content":"<h3 id=\"1-背景\"><a href=\"#1-背景\" class=\"headerlink\" title=\"1. 背景\"></a>1. 背景</h3><p>说来话长，最近感情，工作，生活，接连失意。所以想找个可以打发时间的事做做。用来提高自己的自信心。就刚刚好想到了自己一直没能复原的魔方，于是我就试着摸索，挑战一下自己的智力。</p>\n<blockquote>\n<p>我的学习习惯：从小到大，学习任何一个新东西，总是想先自己把原理搞清楚，做出个成绩之后，再去查看现有的成果对比。而不愿意去查阅度娘或问别人，别人眼中的一根筋。不然问别人搞清楚了也浑身不自在。（这是病，要改）</p>\n</blockquote>\n<h3 id=\"2-自己摸索阶段\"><a href=\"#2-自己摸索阶段\" class=\"headerlink\" title=\"2. 自己摸索阶段\"></a>2. 自己摸索阶段</h3><p>摸索了有大概2天左右吧，啥也没搞懂。除了知道三阶魔方有54个面，8个角块（1个角块3个，所以总共3<em>8=24个面），6个中心块（1个中心块只有1个面，所以总共1</em>6=6），12个棱块（1个棱块2个面，所以总共2*12=24个面），加在一起刚刚好54个面。<br>知道角块可以通过上下旋转棱，进行换位，中心块永远在中心位置，且相对的永远相对，其他一概不知，马丹，前前后后旋转了有6个小时吧，啥也没摸索出来。</p>\n<h3 id=\"3-看视频阶段\"><a href=\"#3-看视频阶段\" class=\"headerlink\" title=\"3. 看视频阶段\"></a>3. 看视频阶段</h3><p>于是我终于投降了，决定看视频学习，复原魔方。以下就是视频链接地址。说来奇怪，1个多小时我就学会啦。真的服了自己的学习能力，为什么自己思考就不行呢？学不会呢？</p>\n<p><a href=\"http://video.rubik.com.cn/\" target=\"_blank\" rel=\"external\">魔方小站</a><br>方法共七步：我去，步骤我就不写了，网站有图，更直观。<br>思路大概是：</p>\n<pre><code>1. 一层一层的完成，而不是一面一面的完成。\n2. 第一层需要调整角块即可，调整思路是：旋转侧面，调整即可。\n3. 第二层就是调整棱角块，思路是从上层调整下来即可。\n4. 第三层略微复杂，视频作者说，先多顶层面十字，然后顶层面对好，剩        下的我基本上就是按照他说的那公式，如果没出来那种情况，就胡乱转        成自己熟悉的情况即可。\n</code></pre><h3 id=\"3-以上的思考，以后学习作为参考\"><a href=\"#3-以上的思考，以后学习作为参考\" class=\"headerlink\" title=\"3. 以上的思考，以后学习作为参考\"></a>3. 以上的思考，以后学习作为参考</h3><ol>\n<li>要改掉自己的不爱问人的毛病，他们都是过来人，肯定会懂的比我多。多问，多与人交流学习。只要有所收获，那么就应该不耻下为。改掉怕麻烦人的毛病。</li>\n<li>学习一个新东西新技能新知识，要学会看视频，找资源，这样可以达到事半功倍的效果，比自己闭门造车好很多，自己想再多也还是不会，毕竟刚开始积累的经验和基础和知识不够。</li>\n<li>遇到自己不熟悉的东西和领域，要学会转化成自己熟悉的情况，这样自己就会解决了。</li>\n<li>可以先做出来成果后，再去思考其中的奥妙和原理，不要老是上一步不理解，就永远不进行下一步。这样永远不会成功。好多事情是需要先看到结果，才能够明白其中的原理和奥妙。</li>\n<li>为了提高自己的自信，一定要有目的的，带着问题的去解决问题，而不是胡思乱想，毫无头绪的乱撞。这样不仅浪费时间，还会让自己更烦，让问题更艰难。</li>\n<li>不要害怕东西多，时间不够，心急是解决不了问题的，不如让自己静下心来，慢点没关系，只要自己一直在进步就好啊。好多问题都是这样，你慢慢来，就会发现，其实并没那么难或多，心急的话，问题永远解决不了。</li>\n<li>以上6点是暂时发现的问题，以后会持续补充。<br>—————————————–2017年1月26日，下午16:24写于上海携程</li>\n</ol>\n","categories":["随笔"],"tags":["学习方式"]},{"title":"第一篇文章markdown语法","url":"http://gruad.github.io/2017/01/26/第一篇文章markdown语法/","content":"<p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p>\n<blockquote>\n<ul>\n<li>整理知识，学习笔记</li>\n<li>发布日记，杂文，所见所想</li>\n<li>撰写发布技术文稿（代码支持）</li>\n<li>撰写发布学术论文（LaTeX 公式支持）</li>\n</ul>\n</blockquote>\n<p><img src=\"https://www.zybuluo.com/static/img/logo.png\" alt=\"cmd-markdown-logo\"></p>\n<p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p>\n<h3 id=\"Windows-Mac-Linux-全平台客户端\"><a href=\"#Windows-Mac-Linux-全平台客户端\" class=\"headerlink\" title=\"Windows/Mac/Linux 全平台客户端\"></a><a href=\"https://www.zybuluo.com/cmd/\" target=\"_blank\" rel=\"external\">Windows/Mac/Linux 全平台客户端</a></h3><blockquote>\n<p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class=\"icon-file\"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p>\n</blockquote>\n<hr>\n<h2 id=\"什么是-Markdown\"><a href=\"#什么是-Markdown\" class=\"headerlink\" title=\"什么是 Markdown\"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p>\n<h3 id=\"1-制作一份待办事宜-Todo-列表\"><a href=\"#1-制作一份待办事宜-Todo-列表\" class=\"headerlink\" title=\"1. 制作一份待办事宜 Todo 列表\"></a>1. 制作一份待办事宜 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表\" target=\"_blank\" rel=\"external\">Todo 列表</a></h3><ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 支持以 PDF 格式导出文稿</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> 新增 Todo 列表功能</li>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> 修复 LaTex 公式渲染问题</li>\n<li style=\"list-style: none\"><input type=\"checkbox\" checked> 新增 LaTex 公式编号功能</li>\n</ul>\n<h3 id=\"2-书写一个质能守恒公式-LaTeX\"><a href=\"#2-书写一个质能守恒公式-LaTeX\" class=\"headerlink\" title=\"2. 书写一个质能守恒公式[^LaTeX]\"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p>\n<h3 id=\"3-高亮一段代码-code\"><a href=\"#3-高亮一段代码-code\" class=\"headerlink\" title=\"3. 高亮一段代码[^code]\"></a>3. 高亮一段代码[^code]</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@requires_authorization</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    <span class=\"comment\"># A comment</span></div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'hello world'</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-高效绘制-流程图\"><a href=\"#4-高效绘制-流程图\" class=\"headerlink\" title=\"4. 高效绘制 流程图\"></a>4. 高效绘制 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图\" target=\"_blank\" rel=\"external\">流程图</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">st=&gt;start: Start</div><div class=\"line\">op=&gt;operation: Your Operation</div><div class=\"line\">cond=&gt;condition: Yes or No?</div><div class=\"line\">e=&gt;end</div><div class=\"line\"></div><div class=\"line\">st-&gt;op-&gt;cond</div><div class=\"line\">cond(yes)-&gt;e</div><div class=\"line\">cond(no)-&gt;op</div></pre></td></tr></table></figure>\n<h3 id=\"5-高效绘制-序列图\"><a href=\"#5-高效绘制-序列图\" class=\"headerlink\" title=\"5. 高效绘制 序列图\"></a>5. 高效绘制 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图\" target=\"_blank\" rel=\"external\">序列图</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Alice-&gt;Bob: Hello Bob, how are you?</div><div class=\"line\">Note right of Bob: Bob thinks</div><div class=\"line\">Bob--&gt;Alice: I am good thanks!</div></pre></td></tr></table></figure>\n<h3 id=\"6-高效绘制-甘特图\"><a href=\"#6-高效绘制-甘特图\" class=\"headerlink\" title=\"6. 高效绘制 甘特图\"></a>6. 高效绘制 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图\" target=\"_blank\" rel=\"external\">甘特图</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">title 项目开发流程</div><div class=\"line\">section 项目确定</div><div class=\"line\">    需求分析       :a1, 2016-06-22, 3d</div><div class=\"line\">    可行性报告     :after a1, 5d</div><div class=\"line\">    概念验证       : 5d</div><div class=\"line\">section 项目实施</div><div class=\"line\">    概要设计      :2016-07-05  , 5d</div><div class=\"line\">    详细设计      :2016-07-08, 10d</div><div class=\"line\">    编码          :2016-07-15, 10d</div><div class=\"line\">    测试          :2016-07-22, 5d</div><div class=\"line\">section 发布验收</div><div class=\"line\">    发布: 2d</div><div class=\"line\">    验收: 3d</div></pre></td></tr></table></figure>\n<h3 id=\"7-绘制表格\"><a href=\"#7-绘制表格\" class=\"headerlink\" title=\"7. 绘制表格\"></a>7. 绘制表格</h3><table>\n<thead>\n<tr>\n<th>项目</th>\n<th style=\"text-align:right\">价格</th>\n<th style=\"text-align:center\">数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>计算机</td>\n<td style=\"text-align:right\">\\$1600</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n<tr>\n<td>手机</td>\n<td style=\"text-align:right\">\\$12</td>\n<td style=\"text-align:center\">12</td>\n</tr>\n<tr>\n<td>管线</td>\n<td style=\"text-align:right\">\\$1</td>\n<td style=\"text-align:center\">234</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"8-更详细语法说明\"><a href=\"#8-更详细语法说明\" class=\"headerlink\" title=\"8. 更详细语法说明\"></a>8. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown\" target=\"_blank\" rel=\"external\">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href=\"https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册\" target=\"_blank\" rel=\"external\">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p>\n<p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p>\n<hr>\n<h2 id=\"什么是-Cmd-Markdown\"><a href=\"#什么是-Cmd-Markdown\" class=\"headerlink\" title=\"什么是 Cmd Markdown\"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p>\n<h3 id=\"1-实时同步预览\"><a href=\"#1-实时同步预览\" class=\"headerlink\" title=\"1. 实时同步预览\"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p>\n<h3 id=\"2-编辑工具栏\"><a href=\"#2-编辑工具栏\" class=\"headerlink\" title=\"2. 编辑工具栏\"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p>\n<p><img src=\"https://www.zybuluo.com/static/img/toolbar-editor.png\" alt=\"tool-editor\"></p>\n<h3 id=\"3-编辑模式\"><a href=\"#3-编辑模式\" class=\"headerlink\" title=\"3. 编辑模式\"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p>\n<h3 id=\"4-实时的云端文稿\"><a href=\"#4-实时的云端文稿\" class=\"headerlink\" title=\"4. 实时的云端文稿\"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p>\n<h3 id=\"5-离线模式\"><a href=\"#5-离线模式\" class=\"headerlink\" title=\"5. 离线模式\"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p>\n<h3 id=\"6-管理工具栏\"><a href=\"#6-管理工具栏\" class=\"headerlink\" title=\"6. 管理工具栏\"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p>\n<p><img src=\"https://www.zybuluo.com/static/img/toolbar-manager.jpg\" alt=\"tool-manager\"></p>\n<p>通过管理工具栏可以：</p>\n<p><i class=\"icon-share\"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class=\"icon-file\"></i> 新建：开始撰写一篇新的文稿<br><i class=\"icon-trash\"></i> 删除：删除当前的文稿<br><i class=\"icon-cloud\"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class=\"icon-reorder\"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class=\"icon-pencil\"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p>\n<h3 id=\"7-阅读工具栏\"><a href=\"#7-阅读工具栏\" class=\"headerlink\" title=\"7. 阅读工具栏\"></a>7. 阅读工具栏</h3><p><img src=\"https://www.zybuluo.com/static/img/toolbar-reader.jpg\" alt=\"tool-manager\"></p>\n<p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p>\n<p>工具栏上的五个图标依次为：</p>\n<p><i class=\"icon-list\"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class=\"icon-chevron-sign-left\"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class=\"icon-adjust\"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class=\"icon-desktop\"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class=\"icon-fullscreen\"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p>\n<h3 id=\"8-阅读模式\"><a href=\"#8-阅读模式\" class=\"headerlink\" title=\"8. 阅读模式\"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class=\"icon-desktop\"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p>\n<h3 id=\"9-标签、分类和搜索\"><a href=\"#9-标签、分类和搜索\" class=\"headerlink\" title=\"9. 标签、分类和搜索\"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p>\n<p>标签： 未分类</p>\n<p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p>\n<p><img src=\"https://www.zybuluo.com/static/img/file-list.png\" alt=\"file-list\"></p>\n<h3 id=\"10-文稿发布和分享\"><a href=\"#10-文稿发布和分享\" class=\"headerlink\" title=\"10. 文稿发布和分享\"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class=\"icon-share\"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p>\n<hr>\n<p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class=\"icon-file\"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p>\n<p>作者 <a href=\"http://weibo.com/ghosert\" target=\"_blank\" rel=\"external\">@ghosert</a><br>2016 年 07月 07日    </p>\n<p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\" target=\"_blank\" rel=\"external\">MathJax</a> 参考更多使用方法。</p>\n<p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>\n","categories":["技术基础"],"tags":["markdown语法"]},{"title":"","url":"http://gruad.github.io/baidu_verify_4RoVvwfS4v.html","content":"4RoVvwfS4v","categories":[],"tags":[]},{"title":"about","url":"http://gruad.github.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://gruad.github.io/category/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://gruad.github.io/link/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://gruad.github.io/project/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://gruad.github.io/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://gruad.github.io/tag/index.html","content":"","categories":[],"tags":[]}]